[
 {
  "question": "How to solve week 7 lecture ?",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "How to resolve week 7 lecture ?",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "How to mitigate week 7 lecture ?",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "Solution for week 7 lecture",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "Provide me some Solution for week 7 lecture",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "mitigation for week 7 lecture",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "How to stop week 7 lecture ?",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "How to defend week 7 lecture ?",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "How to get secured against week 7 lecture ?",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "Solution, week 7 lecture",
  "answer": "Signature-based Selection\n",
  "intent": "solution",
  "key_words": [
   "week",
   "7",
   "lecture"
  ]
 },
 {
  "question": "How to solve indexing with signature ?",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to resolve indexing with signature ?",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to mitigate indexing with signature ?",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "Solution for indexing with signature",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "Provide me some Solution for indexing with signature",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "mitigation for indexing with signature",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to stop indexing with signature ?",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to defend indexing with signature ?",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to get secured against indexing with signature ?",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "Solution, indexing with signature",
  "answer": "Signature-based indexing:\n designed for pmr queries \u00a0 (conjunction of equalities)\n does not try to achieve better than O(n) performance\n attempts to provide an \"efficient\" linear scan\n Each tuple is associated with a signature\n a compact (lossy) descriptor for the tuple\n formed by combining information from multiple attributes\n stored in a signature file, parallel to data file\n Instead of scanning/testing tuples, do pre-filtering via signatures.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to solve indexing with signature ?",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to resolve indexing with signature ?",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to mitigate indexing with signature ?",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "Solution for indexing with signature",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "Provide me some Solution for indexing with signature",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "mitigation for indexing with signature",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to stop indexing with signature ?",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to defend indexing with signature ?",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to get secured against indexing with signature ?",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "Solution, indexing with signature",
  "answer": "File organisation for signature indexing (two files)\n One signature slot per tuple slot; unused signature slots are zeroed.\n Record placement is independent of signatures \u21d2 can use with other indexing.\n",
  "intent": "solution",
  "key_words": [
   "indexing",
   "with",
   "signature"
  ]
 },
 {
  "question": "How to solve signature ?",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "How to resolve signature ?",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "How to mitigate signature ?",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "Solution for signature",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "Provide me some Solution for signature",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "mitigation for signature",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "How to stop signature ?",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "How to defend signature ?",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "How to get secured against signature ?",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "Solution, signature",
  "answer": "A signature \"summarises\" the data in one tuple\n A tuple consists of N attribute values A1 .. An\n A codeword cw(Ai) is\n a bit-string, m bits long, where k bits are set to 1 \u00a0(k \u226a m)\n derived from the value of a single attribute Ai\n A tuple descriptor (signature) is built by combining cw(Ai), i=1..n\n could combine by overlaying or concatenating codewords\n aim to have roughly half of the bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "signature"
  ]
 },
 {
  "question": "How to solve generating codewords ?",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "How to resolve generating codewords ?",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "How to mitigate generating codewords ?",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "Solution for generating codewords",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "Provide me some Solution for generating codewords",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "mitigation for generating codewords",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "How to stop generating codewords ?",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "How to defend generating codewords ?",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "How to get secured against generating codewords ?",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "Solution, generating codewords",
  "answer": "Generating a k-in-m codeword for attribute Ai\n bits codeword(char *attr_value, int m, int k) {    int  nbits = 0;   // count of set bits    bits cword = 0;   // assuming m <= 32 bits    srandom(hash(attr_value));    while (nbits < k) {       int i = random() % m;       if (((1 << i) & cword) == 0) {          cword |= (1 << i);          nbits++;       }    }    return cword;  // m-bits with k 1-bits and m-k 0-bits }",
  "intent": "solution",
  "key_words": [
   "generating",
   "codewords"
  ]
 },
 {
  "question": "How to solve superimposed codewords (simc) ?",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "How to resolve superimposed codewords (simc) ?",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "How to mitigate superimposed codewords (simc) ?",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "Solution for superimposed codewords (simc)",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "Provide me some Solution for superimposed codewords (simc)",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "mitigation for superimposed codewords (simc)",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "How to stop superimposed codewords (simc) ?",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "How to defend superimposed codewords (simc) ?",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "How to get secured against superimposed codewords (simc) ?",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "Solution, superimposed codewords (simc)",
  "answer": "In a superimposed codewords (simc) indexing scheme\n a tuple descriptor is formed by overlaying attribute codewords\n A tuple descriptor desc(r) is\n a bit-string, m bits long, where j \u2264 nk bits are set to 1\n desc(r)\u00a0=\u00a0cw(A1) OR cw(A2) OR ... OR cw(An)\n Method (assuming all n attributes are used in descriptor):\n bits desc = 0  for (i = 1; i <= n; i++) {    bits cw = codeword(A[i])    desc = desc | cw }",
  "intent": "solution",
  "key_words": [
   "superimposed",
   "codewords",
   "(simc)"
  ]
 },
 {
  "question": "How to solve simc query ?",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to resolve simc query ?",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to mitigate simc query ?",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "Solution for simc query",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "Provide me some Solution for simc query",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "mitigation for simc query",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to stop simc query ?",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to defend simc query ?",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to get secured against simc query ?",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "Solution, simc query",
  "answer": "To answer query q in SIMC\n first generate a query descriptor desc(q)\n then use the query descriptor to search the signature file\n desc(q) is formed by OR of codewords for known attributes.\n E.g. consider the query (Perryridge, ?, ?, ?).\n Ai cw(Ai)\n Perryridge 010000000001\n ? 000000000000\n ? 000000000000\n ? 000000000000\n desc(q) 010000000001\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to solve simc query ?",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to resolve simc query ?",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to mitigate simc query ?",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "Solution for simc query",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "Provide me some Solution for simc query",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "mitigation for simc query",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to stop simc query ?",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to defend simc query ?",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to get secured against simc query ?",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "Solution, simc query",
  "answer": "Once we have a query descriptor, we search the signature file:\n pagesToCheck = {} for each descriptor D[i] in signature file {     if (matches(D[i],desc(q))) {         pid = pageOf(tupleID(i))         pagesToCheck = pagesToCheck \u222a pid     } } for each P in pagesToCheck {     Buf = getPage(f,P)     check tuples in Buf for answers } // where ... #define matches(rdesc,qdesc)                ((rdesc & qdesc) == qdesc)",
  "intent": "solution",
  "key_words": [
   "simc",
   "query"
  ]
 },
 {
  "question": "How to solve simc parameter ?",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to resolve simc parameter ?",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to mitigate simc parameter ?",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "Solution for simc parameter",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "Provide me some Solution for simc parameter",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "mitigation for simc parameter",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to stop simc parameter ?",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to defend simc parameter ?",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to get secured against simc parameter ?",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "Solution, simc parameter",
  "answer": "False match probablity pF \u00a0=\u00a0 likelihood of a false match\n How to reduce likelihood of false matches?\n use different hash function for each attribute \u00a0 (hi for Ai)\n increase descriptor size (m)\n choose k so that \u2245 half of bits are set\n  Larger m means reading more descriptor data.\n Having k too high \u00a0\u21d2\u00a0 increased overlapping. Having k too low \u00a0\u21d2\u00a0 increased hash collisions.\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to solve simc parameter ?",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to resolve simc parameter ?",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to mitigate simc parameter ?",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "Solution for simc parameter",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "Provide me some Solution for simc parameter",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "mitigation for simc parameter",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to stop simc parameter ?",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to defend simc parameter ?",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to get secured against simc parameter ?",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "Solution, simc parameter",
  "answer": " 1. start by choosing acceptable pF  \u00a0 (e.g. pF \u2264 10-5 i.e. one false match in 10,000)\n 2. then choose m and k to achieve no more than this pF.\n Formulae to derive m and k given pF and n:\n k \u00a0=\u00a0 1/loge2 . loge ( 1/pF )\n m \u00a0=\u00a0 ( 1/loge 2 )2 . n . loge ( 1/pF )\n",
  "intent": "solution",
  "key_words": [
   "simc",
   "parameter"
  ]
 },
 {
  "question": "How to solve query cost for simc ?",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "How to resolve query cost for simc ?",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "How to mitigate query cost for simc ?",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "Solution for query cost for simc",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "Provide me some Solution for query cost for simc",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "mitigation for query cost for simc",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "How to stop query cost for simc ?",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "How to defend query cost for simc ?",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "How to get secured against query cost for simc ?",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "Solution, query cost for simc",
  "answer": "Cost to answer pmr query: Costpmr = bD + bq\n read r descriptors on bD descriptor pages\n then read bq data pages and check for matches\n bD = ceil( r/cD ) \u00a0and\u00a0 cD = floor(B/ceil(m/8))\n E.g. m=64, \u00a0 B=8192, \u00a0 r=104 \u00a0\u00a0\u00a0\u21d2\u00a0\u00a0\u00a0 cD = 1024, \u00a0 bD=10\n bq includes pages with rq matching tuples and rF false matches\n Expected false matches = rF \u00a0=\u00a0 (r - rq).pF \u00a0\u2245\u00a0 r.pF \u00a0 if rq \u226a r\n E.g. Worst bq = rq+rF, \u00a0 Best bq = 1, \u00a0 Avg bq = ceil(b(rq+rF)/r)\n",
  "intent": "solution",
  "key_words": [
   "query",
   "cost",
   "for",
   "simc"
  ]
 },
 {
  "question": "How to solve false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to resolve false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to mitigate false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Solution for false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Provide me some Solution for false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "mitigation for false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to stop false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to defend false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to get secured against false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Solution, false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to solve page-level simc ?",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "How to resolve page-level simc ?",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "How to mitigate page-level simc ?",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "Solution for page-level simc",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "Provide me some Solution for page-level simc",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "mitigation for page-level simc",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "How to stop page-level simc ?",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "How to defend page-level simc ?",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "How to get secured against page-level simc ?",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "Solution, page-level simc",
  "answer": "SIMC has one descriptor per tuple ... potentially inefficient.\n Alternative approach: one descriptor for each data page.\n Every attribute of every tuple in page contributes to descriptor.\n Size of page descriptor (PD) (clearly larger than tuple descriptor):\n use above formulae but with c.n \"attributes\"\n E.g. n = 4, c = 128, pF = 10-3 \u00a0 \u21d2 \u00a0 m \u2245 7000bits \u2245 900bytes\n Typically, pages are 1..8KB \u00a0\u21d2\u00a0 8..64 PD/page (NPD).\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc"
  ]
 },
 {
  "question": "How to solve page-level simc file ?",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to resolve page-level simc file ?",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to mitigate page-level simc file ?",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Solution for page-level simc file",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Provide me some Solution for page-level simc file",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "mitigation for page-level simc file",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to stop page-level simc file ?",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to defend page-level simc file ?",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to get secured against page-level simc file ?",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Solution, page-level simc file",
  "answer": "File organisation for page-level superimposed codeword index\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to solve false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to resolve false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to mitigate false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Solution for false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Provide me some Solution for false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "mitigation for false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to stop false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to defend false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to get secured against false match probability pf = ?",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Solution, false match probability pf =",
  "answer": "answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to solve page-level simc file ?",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to resolve page-level simc file ?",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to mitigate page-level simc file ?",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Solution for page-level simc file",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Provide me some Solution for page-level simc file",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "mitigation for page-level simc file",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to stop page-level simc file ?",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to defend page-level simc file ?",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to get secured against page-level simc file ?",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Solution, page-level simc file",
  "answer": "Improvement: store b m-bit page descriptors as m b-bit \"bit-slices\"\n ",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to solve page-level simc file ?",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to resolve page-level simc file ?",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to mitigate page-level simc file ?",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Solution for page-level simc file",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Provide me some Solution for page-level simc file",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "mitigation for page-level simc file",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to stop page-level simc file ?",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to defend page-level simc file ?",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to get secured against page-level simc file ?",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "Solution, page-level simc file",
  "answer": "At query time\n matches = ~0  //all ones for each bit i set to 1 in desc(q) {    slice = fetch bit-slice i    matches = matches & slice } for each bit i set to 1 in matches {    fetch page i    scan page for matching records }  Effective because desc(q) typically has less than half bits set to 1\n",
  "intent": "solution",
  "key_words": [
   "page-level",
   "simc",
   "file"
  ]
 },
 {
  "question": "How to solve false match probability pf = ?",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to resolve false match probability pf = ?",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to mitigate false match probability pf = ?",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Solution for false match probability pf =",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Provide me some Solution for false match probability pf =",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "mitigation for false match probability pf =",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to stop false match probability pf = ?",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to defend false match probability pf = ?",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to get secured against false match probability pf = ?",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "Solution, false match probability pf =",
  "answer": "query descriptor has k = 10 bits set to 1\n answer set has 1000 tuples from 100 pages\n 90% of false matches occur on data pages with true match\n 10% of false matches are distributed 1 per page\n Calculate the total number of pages read in answering the query.\n Similarity Retrieval\n",
  "intent": "solution",
  "key_words": [
   "false",
   "match",
   "probability",
   "pf",
   "="
  ]
 },
 {
  "question": "How to solve similarity selection ?",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to resolve similarity selection ?",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to mitigate similarity selection ?",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "Solution for similarity selection",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "Provide me some Solution for similarity selection",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "mitigation for similarity selection",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to stop similarity selection ?",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to defend similarity selection ?",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to get secured against similarity selection ?",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "Solution, similarity selection",
  "answer": "Relational selection is based on a boolean condition C\n evaluate C for each tuple t\n if C(t) is true, add t to result set\n if C(t) is false, t is not part of solution\n result is a set of tuples { t1, t2, ..., tn } all of which satisfy C\n Uses for relational selection:\n precise matching on structured data\n using individual attributes with known, exact values\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to solve similarity selection ?",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to resolve similarity selection ?",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to mitigate similarity selection ?",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "Solution for similarity selection",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "Provide me some Solution for similarity selection",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "mitigation for similarity selection",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to stop similarity selection ?",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to defend similarity selection ?",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to get secured against similarity selection ?",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "Solution, similarity selection",
  "answer": "Similarity selection is used in contexts where\n cannot define a precise matching condition\n can define a measure d of \"distance\" between tuples\n d=0 is an exact match, d>0 is less accurate match\n result is a list of pairs [ (t1,d1), (t2,d2), ..., (tn,dn) ] \u00a0 (ordered by di)\n Uses for similarity matching:\n text or multimedia (image/music) retrieval\n ranked queries in conventional databases\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "selection"
  ]
 },
 {
  "question": "How to solve similarity-based retrieval ?",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to resolve similarity-based retrieval ?",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to mitigate similarity-based retrieval ?",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution for similarity-based retrieval",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Provide me some Solution for similarity-based retrieval",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "mitigation for similarity-based retrieval",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to stop similarity-based retrieval ?",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to defend similarity-based retrieval ?",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to get secured against similarity-based retrieval ?",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution, similarity-based retrieval",
  "answer": "Similarity-based retrieval typically works as follows:\n query is given as a query object q \u00a0 (e.g. sample image)\n system finds objects that are like q \u00a0 (i.e. small distance)\n The system can measure distance between any object and q ...\n How to restrict solution set to only the \"most similar\" objects:\n threshold dmax \u00a0 (only objects t such that dist(t,q) \u2264 dmax)\n count k \u00a0 (k closest objects (k nearest neighbours))\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to solve similarity-based retrieval ?",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to resolve similarity-based retrieval ?",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to mitigate similarity-based retrieval ?",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution for similarity-based retrieval",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Provide me some Solution for similarity-based retrieval",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "mitigation for similarity-based retrieval",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to stop similarity-based retrieval ?",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to defend similarity-based retrieval ?",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to get secured against similarity-based retrieval ?",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution, similarity-based retrieval",
  "answer": "Tuple structure for storing such data typically contains\n id to uniquely identify object \u00a0 (e.g. PostgreSQL oid)\n metadata \u00a0 (e.g. artist, title, genre, date taken, ...)\n value of object itself \u00a0 (e.g. PostgreSQL BLOB or bytea)\n Properties of typical distance functions \u00a0 (on objects x,y,z)\n dist(x,y) \u2265 0, \u00a0\u00a0\u00a0 dist(x,x) = 0, \u00a0\u00a0\u00a0 dist(x,y) = dist(y,x)\n dist(x,z) < dist(x,y) + dist(y,z) \u00a0 (triangle inequality)\n Distance calculation often requires substantial computational effort\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to solve similarity-based retrieval ?",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to resolve similarity-based retrieval ?",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to mitigate similarity-based retrieval ?",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution for similarity-based retrieval",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Provide me some Solution for similarity-based retrieval",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "mitigation for similarity-based retrieval",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to stop similarity-based retrieval ?",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to defend similarity-based retrieval ?",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to get secured against similarity-based retrieval ?",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution, similarity-based retrieval",
  "answer": "Naive approach to similarity-based retrieval\n q = ...    // query object dmax = ... // dmax > 0  =>  using threshold knn = ...  // knn > 0   =>  using nearest-neighbours Dists = [] // empty list foreach tuple t in R {     d = dist(t.val, q)     insert (t.oid,d) into Dists  // sorted on d } n = 0;  Results = [] foreach (i,d) in Dists {     if (dmax > 0 && d > dmax) break;     if (knn > 0 && ++n > knn) break;     insert (i,d) into Results  // sorted on d } return Results; Cost \u00a0=\u00a0 read all r feature vectors \u00a0+\u00a0 compute distance() for each\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to solve similarity-based retrieval ?",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to resolve similarity-based retrieval ?",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to mitigate similarity-based retrieval ?",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution for similarity-based retrieval",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Provide me some Solution for similarity-based retrieval",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "mitigation for similarity-based retrieval",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to stop similarity-based retrieval ?",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to defend similarity-based retrieval ?",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to get secured against similarity-based retrieval ?",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution, similarity-based retrieval",
  "answer": "For some applications, Cost(dist(x,y)) is comparable to Tr\n \u21d2 \u00a0 computing dist(t.val,q) for every tuple t is infeasible.\n To improve this aspect:\n compute feature vector which captures \"critical\" object properties\n store feature vectors \"in parallel\" with objects \u00a0 (cf. signatures)\n compute distance using feature vectors \u00a0 (not objects)\n i.e. replace dist(t,tq) by dist'(vec(t),vec(tq)) in previous algorithm.\n Further optimisation: dimension-reduction to make vectors smaller\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to solve similarity-based retrieval ?",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to resolve similarity-based retrieval ?",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to mitigate similarity-based retrieval ?",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution for similarity-based retrieval",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Provide me some Solution for similarity-based retrieval",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "mitigation for similarity-based retrieval",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to stop similarity-based retrieval ?",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to defend similarity-based retrieval ?",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to get secured against similarity-based retrieval ?",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "Solution, similarity-based retrieval",
  "answer": "Content of feature vectors depends on application ...\n image ... colour histogram (e.g. 100's of values/dimensions)\n music ... loudness/pitch/tone (e.g. 100's of values/dimensions)\n text ... term frequencies (e.g. 1000's of values/dimensions)\n Typically use multiple features, concatenated into single vector.\n Feature vectors represent points in a very high-dimensional space.\n Query: feature vector representing one point in vh-dim space.\n Answer: list of objects \"near to\" query object in this space.\n",
  "intent": "solution",
  "key_words": [
   "similarity-based",
   "retrieval"
  ]
 },
 {
  "question": "How to solve approach to knn retrieval ?",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to resolve approach to knn retrieval ?",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to mitigate approach to knn retrieval ?",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "Solution for approach to knn retrieval",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "Provide me some Solution for approach to knn retrieval",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "mitigation for approach to knn retrieval",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to stop approach to knn retrieval ?",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to defend approach to knn retrieval ?",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to get secured against approach to knn retrieval ?",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "Solution, approach to knn retrieval",
  "answer": "Partition-based\n use auxiliary data structure to identify candidates\n space/data-partitioning methods: e.g. k-d-B-tree, R-tree, ...\n unfortunately, such methods \"fail\" when #dims > 10..20\n absolute upper bound on d before linear scan is best d = 610\n Approximation-based\n use approximating data structure to identify candidates\n signatures: VA-files\n projections: iDistance, LSH, MedRank, CurveIX, Pyramid\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to solve approach to knn retrieval ?",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to resolve approach to knn retrieval ?",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to mitigate approach to knn retrieval ?",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "Solution for approach to knn retrieval",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "Provide me some Solution for approach to knn retrieval",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "mitigation for approach to knn retrieval",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to stop approach to knn retrieval ?",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to defend approach to knn retrieval ?",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to get secured against approach to knn retrieval ?",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "Solution, approach to knn retrieval",
  "answer": "Above approaches mostly try to reduce number of objects considered.\n Other optimisations to make kNN retrieval faster\n reduce I/O by reducing size of vectors \u00a0 (compression, d-reduction)\n reduce I/O by placing \"similar\" records together \u00a0 (clustering)\n reduce I/O by remembering previous pages \u00a0 (caching)\n reduce cpu by making distance computation faster\n",
  "intent": "solution",
  "key_words": [
   "approach",
   "to",
   "knn",
   "retrieval"
  ]
 },
 {
  "question": "How to solve similarity retrieval in postgresql ?",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to resolve similarity retrieval in postgresql ?",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to mitigate similarity retrieval in postgresql ?",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution for similarity retrieval in postgresql",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Provide me some Solution for similarity retrieval in postgresql",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "mitigation for similarity retrieval in postgresql",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to stop similarity retrieval in postgresql ?",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to defend similarity retrieval in postgresql ?",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to get secured against similarity retrieval in postgresql ?",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution, similarity retrieval in postgresql",
  "answer": "PostgreSQL has always supported simple \"similarity\" on strings\n select * from Students where name like '%oo%'; select * from Students where name ~ '[Ss]mit'; Also provides support for ranked similarity on text values\n using tsvector data type \u00a0(stemmed, stopped feature vector for text)\n using tsquery data type \u00a0(stemmed, stopped feature vector for strings)\n using @@ similarity operator\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to solve similarity retrieval in postgresql ?",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to resolve similarity retrieval in postgresql ?",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to mitigate similarity retrieval in postgresql ?",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution for similarity retrieval in postgresql",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Provide me some Solution for similarity retrieval in postgresql",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "mitigation for similarity retrieval in postgresql",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to stop similarity retrieval in postgresql ?",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to defend similarity retrieval in postgresql ?",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to get secured against similarity retrieval in postgresql ?",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution, similarity retrieval in postgresql",
  "answer": "Example of PostgreSQL text retrieval:\n create table Docs    ( id integer, title text, body text ); // add column to hold document feature vectors alter table Docs add column features tsvector; update Docs set features =    to_tsvector('english', title||' '||body); // ask query and get results in ranked order select title, ts_rank(d.features, query) as rank from   Docs d,        to_tsquery('potter|(roger&rabbit)') as query where  query @@ d.features order  by rank desc limit 10; For more details, see PostgreSQL documentation, Chapter 12.\n Implementing Join\n",
  "intent": "solution",
  "key_words": [
   "similarity",
   "retrieval",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to solve join ?",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "How to resolve join ?",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "How to mitigate join ?",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "Solution for join",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for join",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "mitigation for join",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "How to stop join ?",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "How to defend join ?",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "How to get secured against join ?",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "Solution, join",
  "answer": "DBMSs are engines to store, combine and filter information.\n Join (\u22c8) is the primary means of combining information.\n Join is important and potentially expensive  Most common join condition: equijoin, e.g. (R.pk = S.fk)\n Join varieties (natural, inner, outer, semi, anti) all behave similarly.\n We consider three strategies for implementing join\n nested loop ... simple, widely applicable, inefficient without buffering\n sort-merge ... works best if tables are soted on join attributes\n hash-based ... requires good hash function and sufficient buffering\n",
  "intent": "solution",
  "key_words": [
   "join"
  ]
 },
 {
  "question": "How to solve nested loop join ?",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to resolve nested loop join ?",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to mitigate nested loop join ?",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution for nested loop join",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for nested loop join",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "mitigation for nested loop join",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to stop nested loop join ?",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to defend nested loop join ?",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to get secured against nested loop join ?",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution, nested loop join",
  "answer": "Basic strategy (R.a \u22c8 S.b):\n Result = {} for each page i in R {    pageR = getPage(R,i)    for each page j in S {       pageS = getPage(S,j)       for each pair of tuples tR,tS                        from pageR,pageS {          if (tR.a == tS.b)             Result = Result \u222a (tR:tS) }  }  } Needs input buffers for R and S, output buffer for \"joined\" tuples\n Terminology: R is outer relation, S is inner relation\n Cost = bR . bS \u00a0 ... \u00a0 ouch!\n",
  "intent": "solution",
  "key_words": [
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to solve block nested loop join ?",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to resolve block nested loop join ?",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to mitigate block nested loop join ?",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution for block nested loop join",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for block nested loop join",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "mitigation for block nested loop join",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to stop block nested loop join ?",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to defend block nested loop join ?",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to get secured against block nested loop join ?",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution, block nested loop join",
  "answer": "Method (for N memory buffers):\n read N-2-page chunk of R into memory buffers\n for each S page  \u00a0\u00a0\u00a0 check join condition on all (tR,tS) pairs in buffers\n repeat for all N-2-page chunks of R\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to solve block nested loop join ?",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to resolve block nested loop join ?",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to mitigate block nested loop join ?",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution for block nested loop join",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for block nested loop join",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "mitigation for block nested loop join",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to stop block nested loop join ?",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to defend block nested loop join ?",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to get secured against block nested loop join ?",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution, block nested loop join",
  "answer": "Best-case scenario: bR \u2264 N-2\n read bR pages of relation R into buffers\n while R is buffered, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS\n Typical-case scenario: bR > N-2\n read ceil(bR/N-2) chunks of pages from R\n for each chunk, read bS pages of S\n Cost \u00a0 = \u00a0 bR + bS . ceil(bR/N-2)\n Note: always requires rR.rS checks of the join condition\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to solve block nested loop join ?",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to resolve block nested loop join ?",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to mitigate block nested loop join ?",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution for block nested loop join",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for block nested loop join",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "mitigation for block nested loop join",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to stop block nested loop join ?",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to defend block nested loop join ?",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to get secured against block nested loop join ?",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution, block nested loop join",
  "answer": " Many queries have the form\n select * from R,S where r.i=s.j and r.x=k This would typically be evaluated as\n Join [i=j] ((Sel[r.x=k](R)), S)\n If |Sel[r.x=k](R)| is small \u21d2 may fit in memory (in small #buffers)\n",
  "intent": "solution",
  "key_words": [
   "block",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to solve index nested loop join ?",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to resolve index nested loop join ?",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to mitigate index nested loop join ?",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution for index nested loop join",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for index nested loop join",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "mitigation for index nested loop join",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to stop index nested loop join ?",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to defend index nested loop join ?",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to get secured against index nested loop join ?",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution, index nested loop join",
  "answer": "A problem with nested-loop join:\n needs repeated scans of entire inner relation S\n If there is an index on S, we can avoid such repeated scanning.\n Consider Join[R.i=S.j](R,S):\n for each tuple r in relation R {     use index to select tuples         from S where s.j = r.i     for each selected tuple s from S {         add (r,s) to result }   }",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to solve index nested loop join ?",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to resolve index nested loop join ?",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to mitigate index nested loop join ?",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution for index nested loop join",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for index nested loop join",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "mitigation for index nested loop join",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to stop index nested loop join ?",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to defend index nested loop join ?",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to get secured against index nested loop join ?",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "Solution, index nested loop join",
  "answer": "This method requires:\n one scan of R relation (bR)\n only one buffer needed, since we use R tuple-at-a-time\n for each tuple in R (rR), one index lookup on S\n cost depends on type of index and number of results\n best case is when each R.i matches few S tuples\n Cost \u00a0 = \u00a0 bR + rR.SelS \u00a0\u00a0 (SelS is the cost of performing a select on S).\n Typical SelS \u00a0=\u00a0 1-2 (hashing) .. bq (unclustered index)\n Trade-off: \u00a0 rR.SelS \u00a0vs\u00a0 bR.bS, \u00a0 where \u00a0 bR \u226a rR and SelS \u226a bS\n",
  "intent": "solution",
  "key_words": [
   "index",
   "nested",
   "loop",
   "join"
  ]
 },
 {
  "question": "How to solve sort-merge join ?",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to resolve sort-merge join ?",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to mitigate sort-merge join ?",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution for sort-merge join",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for sort-merge join",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "mitigation for sort-merge join",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to stop sort-merge join ?",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to defend sort-merge join ?",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to get secured against sort-merge join ?",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution, sort-merge join",
  "answer": "Basic approach:\n sort both relations on join attribute \u00a0 (reminder: Join[R.i=S.j](R,S))\n scan together using merge to form result (r,s) tuples\n Advantages:\n no need to deal with \"entire\" S relation for each r tuple\n deal with runs of matching R and S tuples\n Disadvantages:\n cost of sorting both relations \u00a0 (already sorted on join key?)\n some rescanning required when long runs of S tuples\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to solve sort-merge join ?",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to resolve sort-merge join ?",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to mitigate sort-merge join ?",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution for sort-merge join",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for sort-merge join",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "mitigation for sort-merge join",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to stop sort-merge join ?",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to defend sort-merge join ?",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to get secured against sort-merge join ?",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution, sort-merge join",
  "answer": "Method requires several cursors to scan sorted relations:\n r = current record in R relation\n s = start of current run in S relation\n ss = current record in current run in S relation\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to solve sort-merge join ?",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to resolve sort-merge join ?",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to mitigate sort-merge join ?",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution for sort-merge join",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for sort-merge join",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "mitigation for sort-merge join",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to stop sort-merge join ?",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to defend sort-merge join ?",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to get secured against sort-merge join ?",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution, sort-merge join",
  "answer": "Algorithm using query iterators/scanners:\n Query ri, si;  Tuple r,s;  ri = startScan(\"SortedR\"); si = startScan(\"SortedS\"); while ((r = nextTuple(ri)) != NULL        && (s = nextTuple(si)) != NULL) {     // align cursors to start of next common run     while (r != NULL && r.i < s.j)            r = nextTuple(ri);     if (r == NULL) break;     while (s != NULL && r.i > s.j)            s = nextTuple(si);     if (s == NULL) break;     // must have (r.i == s.j) here ...",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to solve sort-merge join ?",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to resolve sort-merge join ?",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to mitigate sort-merge join ?",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution for sort-merge join",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for sort-merge join",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "mitigation for sort-merge join",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to stop sort-merge join ?",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to defend sort-merge join ?",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to get secured against sort-merge join ?",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution, sort-merge join",
  "answer": "...     // remember start of current run in S     TupleID startRun = scanCurrent(si)     // scan common run, generating result tuples     while (r != NULL && r.i == s.j) {         while (s != NULL and s.j == r.i) {             addTuple(outbuf, combine(r,s));             if (isFull(outbuf)) {                 writePage(outf, outp++, outbuf);                 clearBuf(outbuf);             }             s = nextTuple(si);         }         r = nextTuple(ri);         setScan(si, startRun);     } }",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to solve sort-merge join ?",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to resolve sort-merge join ?",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to mitigate sort-merge join ?",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution for sort-merge join",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for sort-merge join",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "mitigation for sort-merge join",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to stop sort-merge join ?",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to defend sort-merge join ?",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to get secured against sort-merge join ?",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution, sort-merge join",
  "answer": "Buffer requirements:\n for sort phase:\n as many as possible (remembering that cost is O(logN) )\n if insufficient buffers, sorting cost can dominate\n for merge phase:\n one output buffer for result\n one input buffer for relation R\n (preferably) enough buffers for longest run in S\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to solve sort-merge join ?",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to resolve sort-merge join ?",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to mitigate sort-merge join ?",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution for sort-merge join",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for sort-merge join",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "mitigation for sort-merge join",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to stop sort-merge join ?",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to defend sort-merge join ?",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to get secured against sort-merge join ?",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "Solution, sort-merge join",
  "answer": "Cost of sort-merge join.\n Step 1: sort each relation \u00a0 (if not already sorted):\n Cost = 2.bR (1 + logN-1(bR /N)) \u00a0+\u00a0 2.bS (1 + logN-1(bS /N))  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 (where N = number of memory buffers)\n Step 2: merge sorted relations:\n if every run of values in S fits completely in buffers,  merge requires single scan, \u00a0 Cost = bR + bS\n if some runs in of values in S are larger than buffers,  need to re-scan run for each corresponding value from R\n",
  "intent": "solution",
  "key_words": [
   "sort-merge",
   "join"
  ]
 },
 {
  "question": "How to solve hash join ?",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve hash join ?",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate hash join ?",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for hash join",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for hash join",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for hash join",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop hash join ?",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend hash join ?",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against hash join ?",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, hash join",
  "answer": "Basic idea:\n use hashing as a technique to partition relations\n to avoid having to consider all pairs of tuples\n Requires sufficent memory buffers\n to hold substantial portions of partitions\n (preferably) to hold largest partition of outer relation\n Other issues:\n works only for equijoin \u00a0 R.i=S.j \u00a0 (but this is a common case)\n susceptible to data skew \u00a0 (or poor hash function)\n Variations: \u00a0 simple, \u00a0 grace, \u00a0 hybrid.\n",
  "intent": "solution",
  "key_words": [
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve simple hash join ?",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve simple hash join ?",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate simple hash join ?",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for simple hash join",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for simple hash join",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for simple hash join",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop simple hash join ?",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend simple hash join ?",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against simple hash join ?",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, simple hash join",
  "answer": "Basic approach:\n hash part of outer relation R into memory buffers (build)\n scan inner relation S, using hash to search (probe)\n if R.i=S.j, then h(R.i)=h(S.j) \u00a0 (hash to same buffer)\n only need to check one memory buffer for each S tuple\n repeat until whole of R has been processed\n No overflows allowed in in-memory hash table\n works best with uniform hash function\n can be adversely affected by data/hash skew\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve simple hash join ?",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve simple hash join ?",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate simple hash join ?",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for simple hash join",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for simple hash join",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for simple hash join",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop simple hash join ?",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend simple hash join ?",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against simple hash join ?",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, simple hash join",
  "answer": "Data flow:\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve simple hash join ?",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve simple hash join ?",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate simple hash join ?",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for simple hash join",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for simple hash join",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for simple hash join",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop simple hash join ?",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend simple hash join ?",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against simple hash join ?",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, simple hash join",
  "answer": "Algorithm for simple hash join Join[R.i=S.j](R,S):\n for each tuple r in relation R {    if (buffer[h(R.i)] is full) {       for each tuple s in relation S {          for each tuple rr in buffer[h(S.j)] {             if ((rr,s) satisfies join condition) {                add (rr,s) to result       }  }  }       clear all hash table buffers    }    insert r into buffer[h(R.i)] } # join tests \u00a0\u2264\u00a0 rS.cR \u00a0\u00a0 (cf. nested-loop \u00a0rS.rR)\n # page reads depends on #buffers N and properties of data/hash.\n",
  "intent": "solution",
  "key_words": [
   "simple",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve grace hash join ?",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve grace hash join ?",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate grace hash join ?",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for grace hash join",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for grace hash join",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for grace hash join",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop grace hash join ?",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend grace hash join ?",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against grace hash join ?",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, grace hash join",
  "answer": "Basic approach (for R \u22c8 S ):\n partition both relations on join attribute using hashing (h1)\n load each partition of R into N-buffer hash table (h2)\n scan through corresponding partition of S to form results\n repeat until all partitions exhausted\n For best-case cost (O(bR + bS) ):\n need \u2265 \u221abR buffers to hold largest partition of outer relation\n If < \u221abR buffers or poor hash distribution\n need to scan some partitions of S multiple times\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve grace hash join ?",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve grace hash join ?",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate grace hash join ?",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for grace hash join",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for grace hash join",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for grace hash join",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop grace hash join ?",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend grace hash join ?",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against grace hash join ?",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, grace hash join",
  "answer": "Partition phase (applied to both R and S):\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve grace hash join ?",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve grace hash join ?",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate grace hash join ?",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for grace hash join",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for grace hash join",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for grace hash join",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop grace hash join ?",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend grace hash join ?",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against grace hash join ?",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, grace hash join",
  "answer": "Probe/join phase:\n The second hash function (h2) simply speeds up the matching process.  Without it, would need to scan entire R partition for each record in S partition.\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve grace hash join ?",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve grace hash join ?",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate grace hash join ?",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for grace hash join",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for grace hash join",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for grace hash join",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop grace hash join ?",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend grace hash join ?",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against grace hash join ?",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, grace hash join",
  "answer": "Cost of grace hash join:\n #pages in all partition files of Rel \u2245 bRel \u00a0 (maybe slightly more)\n partition relation R ... \u00a0 Cost \u00a0=\u00a0 bR.Tr + bR.Tw \u00a0=\u00a0 2bR\n partition relation S ... \u00a0 Cost \u00a0=\u00a0 bS.Tr + bS.Tw \u00a0=\u00a0 2bS\n probe/join requires one scan of each (partitioned) relation  Cost \u00a0=\u00a0 bR + bS\n all hashing and comparison occurs in memory \u00a0 \u21d2 \u00a0 \u22450 cost\n Total Cost \u00a0 = \u00a0 2bR + 2bS + bR + bS \u00a0 = \u00a0 3 (bR + bS)\n",
  "intent": "solution",
  "key_words": [
   "grace",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve hybrid hash join ?",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve hybrid hash join ?",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate hybrid hash join ?",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for hybrid hash join",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for hybrid hash join",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for hybrid hash join",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop hybrid hash join ?",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend hybrid hash join ?",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against hybrid hash join ?",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, hybrid hash join",
  "answer": "A variant of grace join if we have \u221abR < N < bR+2\n create k\u226aN partitions,\u00a0 m in memory,\u00a0 k-m on disk\n buffers: 1 input, k-m output, p = N-(k-m)-1 for in-memory partitions\n When we come to scan and partition S relation\n any tuple with hash in range 0..m-1 can be resolved\n other tuples are written to one of k partition files for S\n Final phase is same as grace join, but with only k partitions.\n Comparison:\n grace hash join creates N-1 partitions on disk\n hybrid hash join creates m (memory) + k (disk) partitions\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve hybrid hash join ?",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve hybrid hash join ?",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate hybrid hash join ?",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for hybrid hash join",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for hybrid hash join",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for hybrid hash join",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop hybrid hash join ?",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend hybrid hash join ?",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against hybrid hash join ?",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, hybrid hash join",
  "answer": "First phase of hybrid hash join with m=1 (partitioning R):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve hybrid hash join ?",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve hybrid hash join ?",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate hybrid hash join ?",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for hybrid hash join",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for hybrid hash join",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for hybrid hash join",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop hybrid hash join ?",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend hybrid hash join ?",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against hybrid hash join ?",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, hybrid hash join",
  "answer": "Next phase of hybrid hash join with m=1 (partitioning S):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve hybrid hash join ?",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve hybrid hash join ?",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate hybrid hash join ?",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for hybrid hash join",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for hybrid hash join",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for hybrid hash join",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop hybrid hash join ?",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend hybrid hash join ?",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against hybrid hash join ?",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, hybrid hash join",
  "answer": "Final phase of hybrid hash join with m=1 (finishing join):\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve hybrid hash join ?",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to resolve hybrid hash join ?",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to mitigate hybrid hash join ?",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution for hybrid hash join",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Provide me some Solution for hybrid hash join",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "mitigation for hybrid hash join",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to stop hybrid hash join ?",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to defend hybrid hash join ?",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to get secured against hybrid hash join ?",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "Solution, hybrid hash join",
  "answer": "Some observations:\n with k partitions, each partition has expected size bR/k\n holding m partitions in memory needs \u2308mbR/k\u2309 buffers\n trade-off between in-memory partition space and #partitions\n Best-cost scenario:\n m = 1, \u00a0 k \u2245 \u2308bR/N\u2309 \u00a0\u00a0 (satisfying above constraint)\n Other notes:\n if N = bR+2, using block nested loop join is simpler\n cost depends on N (but less than grace hash join)\n",
  "intent": "solution",
  "key_words": [
   "hybrid",
   "hash",
   "join"
  ]
 },
 {
  "question": "How to solve join summary ?",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "How to resolve join summary ?",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "How to mitigate join summary ?",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "Solution for join summary",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "Provide me some Solution for join summary",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "mitigation for join summary",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "How to stop join summary ?",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "How to defend join summary ?",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "How to get secured against join summary ?",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "Solution, join summary",
  "answer": "No single join algorithm is superior in some overall sense.\n Which algorithm is best for a given query depends on:\n sizes of relations being joined, \u00a0 size of buffer pool\n any indexing on relations, \u00a0 whether relations are sorted\n which attributes and operations are used in the query\n number of tuples in S matching each tuple in R\n distribution of data values (uniform, skew, ...)\n Choosing the \"best\" join algorithm is critical because the cost difference between best and worst case can be very\n large.\n E.g. \u00a0 Join[id=stude](Student,Enrolled): \u00a0 3,000 ... 2,000,000\n",
  "intent": "solution",
  "key_words": [
   "join",
   "summary"
  ]
 },
 {
  "question": "How to solve join in postgresql ?",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to resolve join in postgresql ?",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to mitigate join in postgresql ?",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution for join in postgresql",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Provide me some Solution for join in postgresql",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "mitigation for join in postgresql",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to stop join in postgresql ?",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to defend join in postgresql ?",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to get secured against join in postgresql ?",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution, join in postgresql",
  "answer": "Join implementations are under: src/backend/executor\n PostgreSQL suports three kinds of join:\n nested loop join (nodeNestloop.c)\n sort-merge join \u00a0 (nodeMergejoin.c)\n hash join \u00a0 (nodeHashjoin.c) \u00a0 (hybrid hash join)\n Query optimiser chooses appropriate join, by considering\n physical characteristics of tables being joined\n estimated selectivity (likely number of result tuples)\n",
  "intent": "solution",
  "key_words": [
   "join",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to solve query evaluation ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to resolve query evaluation ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to mitigate query evaluation ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution for query evaluation",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Provide me some Solution for query evaluation",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "mitigation for query evaluation",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to stop query evaluation ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to defend query evaluation ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to get secured against query evaluation ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution, query evaluation",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to solve query evaluation ?",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to resolve query evaluation ?",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to mitigate query evaluation ?",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution for query evaluation",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Provide me some Solution for query evaluation",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "mitigation for query evaluation",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to stop query evaluation ?",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to defend query evaluation ?",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to get secured against query evaluation ?",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution, query evaluation",
  "answer": "A query in SQL:\n states what kind of answers are required (declarative)\n does not say how they should be computed (procedural)\n A query evaluator/processor :\n takes declarative description of query \u00a0 (in SQL)\n parses query to internal representation \u00a0 (relational algebra)\n determines plan for answering query \u00a0 (expressed as DBMS ops)\n executes method via DBMS engine \u00a0 (to produce result tuples)\n  Some DBMSs can save query plans for later re-use.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to solve query evaluation ?",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to resolve query evaluation ?",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to mitigate query evaluation ?",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution for query evaluation",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Provide me some Solution for query evaluation",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "mitigation for query evaluation",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to stop query evaluation ?",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to defend query evaluation ?",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to get secured against query evaluation ?",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution, query evaluation",
  "answer": "Internals of the query evaluation \"black-box\":\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to solve query evaluation ?",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to resolve query evaluation ?",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to mitigate query evaluation ?",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution for query evaluation",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Provide me some Solution for query evaluation",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "mitigation for query evaluation",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to stop query evaluation ?",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to defend query evaluation ?",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to get secured against query evaluation ?",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution, query evaluation",
  "answer": "DBMSs provide several \"flavours\" of each RA operation.\n For example:\n several \"versions\" of selection (\u03c3) are available\n each version is effective for a particular kind of selection, e.g\n select * from R where id = 100  -- hashing select * from S                 -- Btree index where age > 18 and age < 35 select * from T                 -- MALH file where a = 1 and b = 'a' and c = 1.4 Similarly, \u03c0 and \u22c8 have versions to match specific query types.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to solve query evaluation ?",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to resolve query evaluation ?",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to mitigate query evaluation ?",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution for query evaluation",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Provide me some Solution for query evaluation",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "mitigation for query evaluation",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to stop query evaluation ?",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to defend query evaluation ?",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to get secured against query evaluation ?",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "Solution, query evaluation",
  "answer": "We call these specialised version of RA operations RelOps.\n One major task of the query processor:\n given a set of RA operations to be executed\n find a combination of RelOps to do this efficiently\n Requires the query translator/optimiser to consider\n information about relations (e.g. sizes, primary keys, ...)\n information about operations (e.g. selection reduces size)\n RelOps are realised at execution time\n as a collection of inter-communicating nodes\n communicating either via pipelines or temporary relations\n",
  "intent": "solution",
  "key_words": [
   "query",
   "evaluation"
  ]
 },
 {
  "question": "How to solve terminology variation ?",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "How to resolve terminology variation ?",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "How to mitigate terminology variation ?",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "Solution for terminology variation",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "Provide me some Solution for terminology variation",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "mitigation for terminology variation",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "How to stop terminology variation ?",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "How to defend terminology variation ?",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "How to get secured against terminology variation ?",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "Solution, terminology variation",
  "answer": "Relational algebra expression of SQL query\n intermediate query representation\n logical query plan\n Execution plan as collection of RelOps\n query evaluation plan\n query execution plan\n physical query plan\n Representation of RA operators and expressions\n \u03c3 = Select = Sel, \u00a0\u00a0\u00a0 \u03c0 = Project = Proj\n R \u22c8 S = R Join S = Join(R,S), \u00a0\u00a0\u00a0 \u2227 = &, \u00a0\u00a0\u00a0 \u2228 = |\n",
  "intent": "solution",
  "key_words": [
   "terminology",
   "variation"
  ]
 },
 {
  "question": "How to solve query translation ?",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to resolve query translation ?",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to mitigate query translation ?",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "Solution for query translation",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "Provide me some Solution for query translation",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "mitigation for query translation",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to stop query translation ?",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to defend query translation ?",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to get secured against query translation ?",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "Solution, query translation",
  "answer": "Query translation: \u00a0 SQL statement text \u2192 RA expression\n",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to solve query translation ?",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to resolve query translation ?",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to mitigate query translation ?",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "Solution for query translation",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "Provide me some Solution for query translation",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "mitigation for query translation",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to stop query translation ?",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to defend query translation ?",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to get secured against query translation ?",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "Solution, query translation",
  "answer": "Translation step: \u00a0 SQL text \u2192 RA expression\n Example:\n SQL: select name from Students where id=7654321; -- is translated to RA:  Proj[name](Sel[id=7654321]Students) Processes: \u00a0lexer/parser, \u00a0mapping rules, \u00a0rewriting rules.\n Mapping from SQL to RA may include some optimisations, e.g.\n  select * from Students where id = 54321 and age > 50; -- is translated to Sel[age>50](Sel[id=54321]Students) -- rather than ... because of index on id Sel[id=54321&age>50](Students)",
  "intent": "solution",
  "key_words": [
   "query",
   "translation"
  ]
 },
 {
  "question": "How to solve parsing sql ?",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "How to resolve parsing sql ?",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "How to mitigate parsing sql ?",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "Solution for parsing sql",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "Provide me some Solution for parsing sql",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "mitigation for parsing sql",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "How to stop parsing sql ?",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "How to defend parsing sql ?",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "How to get secured against parsing sql ?",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "Solution, parsing sql",
  "answer": "Parsing task is similar to that for programming languages.\n Language elements:\n keywords: \u00a0 create, \u00a0 select, \u00a0 from, \u00a0 where, \u00a0 ...\n identifiers: \u00a0 Students, \u00a0 name, \u00a0 id, \u00a0 CourseCode, \u00a0 ...\n operators: \u00a0 +, \u00a0 -, \u00a0 =, \u00a0 <, \u00a0 >, \u00a0 AND, \u00a0 OR, \u00a0 NOT, \u00a0 IN, \u00a0 ...\n constants: \u00a0 'abc', \u00a0 123, \u00a0 3.1, \u00a0 '01-jan-1970', \u00a0 ...\n PostgreSQL parser ...\n implemented via lex/yacc \u00a0 (src/backend/parser)\n maps all identifiers to lower-case \u00a0 (A-Z \u2192 a-z)\n needs to handle user-extendable operator set\n makes extensive use of catalog \u00a0 (src/backend/catalog)\n",
  "intent": "solution",
  "key_words": [
   "parsing",
   "sql"
  ]
 },
 {
  "question": "How to solve mapping sql to relational algebra ?",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to resolve mapping sql to relational algebra ?",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to mitigate mapping sql to relational algebra ?",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Solution for mapping sql to relational algebra",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Provide me some Solution for mapping sql to relational algebra",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "mitigation for mapping sql to relational algebra",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to stop mapping sql to relational algebra ?",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to defend mapping sql to relational algebra ?",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to get secured against mapping sql to relational algebra ?",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Solution, mapping sql to relational algebra",
  "answer": "A given SQL query typically has many translations to RA.\n For example:\n SELECT s.name, e.subj FROM   Students s, Enrolments e WHERE  s.id = e.sid AND e.mark < 50; is equivalent to any of\n \u03c0s.name,e.subj( \u03c3s.id=e.sid \u2227 e.mark<50 ( Students \u00d7 Enrolments ) )\n \u03c0s.name,e.subj( \u03c3s.id=e.sid ( \u03c3e.mark<50 ( Students \u00d7 Enrolments ) ) )\n \u03c0s.name,e.subj( \u03c3e.mark<50 ( Students \u22c8s.id=e.sid Enrolments ) ) )\n \u03c0s.name,e.subj( Students \u22c8s.id=e.sid ( \u03c3e.mark<50 ( Enrolments ) ) )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to solve mapping sql to relational algebra ?",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to resolve mapping sql to relational algebra ?",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to mitigate mapping sql to relational algebra ?",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Solution for mapping sql to relational algebra",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Provide me some Solution for mapping sql to relational algebra",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "mitigation for mapping sql to relational algebra",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to stop mapping sql to relational algebra ?",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to defend mapping sql to relational algebra ?",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to get secured against mapping sql to relational algebra ?",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Solution, mapping sql to relational algebra",
  "answer": "More complex example:\n select   distinct s.code from     Course c, Subject s, Enrolment e where    c.id = e.course and c.subject = s.id group by s.id  having count(*) > 100; can be translated to the relational algebra expression\n Uniq(Proj[code](     GroupSelect[groupSize>100](         GroupBy[s.id] (             Enrolment \u22c8 Course \u22c8 Subjects ))))",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to solve mapping sql to relational algebra ?",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to resolve mapping sql to relational algebra ?",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to mitigate mapping sql to relational algebra ?",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Solution for mapping sql to relational algebra",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Provide me some Solution for mapping sql to relational algebra",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "mitigation for mapping sql to relational algebra",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to stop mapping sql to relational algebra ?",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to defend mapping sql to relational algebra ?",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to get secured against mapping sql to relational algebra ?",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "Solution, mapping sql to relational algebra",
  "answer": "The join operations could be done in two different ways:\n Note: for a join on n tables, there are potentially O(n!) possible trees\n The query optimiser aims to find version with lowest total cost.\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "sql",
   "to",
   "relational",
   "algebra"
  ]
 },
 {
  "question": "How to solve mapping rule ?",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to resolve mapping rule ?",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to mitigate mapping rule ?",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution for mapping rule",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Provide me some Solution for mapping rule",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "mitigation for mapping rule",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to stop mapping rule ?",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to defend mapping rule ?",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to get secured against mapping rule ?",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution, mapping rule",
  "answer": "Mapping from SQL \u2192 RA expression requires:\n a collection of templates, \u22651 for each kind of query\n a process to match an SQL statement to a template\n mapping rules for translating matched query into RA\n May need to apply >1 templates to map whole SQL statement.\n After mapping, apply rewriting rules to \"improve\" RA expression\n convert to equivalent, simpler, more efficient expression\n  Note: PostgreSQL also has user-defined mapping rules (CREATE RULE)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to solve mapping rule ?",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to resolve mapping rule ?",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to mitigate mapping rule ?",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution for mapping rule",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Provide me some Solution for mapping rule",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "mitigation for mapping rule",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to stop mapping rule ?",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to defend mapping rule ?",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to get secured against mapping rule ?",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution, mapping rule",
  "answer": "Projection:\n SELECT \u00a0 a+b\u00a0AS\u00a0x, c\u00a0AS\u00a0y \u00a0 FROM \u00a0 R ... \u21d2 \u00a0\u00a0 Proj[x\u2190a+b, y\u2190c](R)\n SQL projection extends RA projection with renaming and assignment\n Join:\n SELECT ... FROM ... R, S ... WHERE ... R.f \u00a0op\u00a0 S.g ... , \u00a0\u00a0 or\n SELECT ... FROM ... R\u00a0JOIN\u00a0S ON \u00a0(R.f\u00a0op\u00a0S.g) ... WHERE ...\n \u21d2 \u00a0\u00a0 Join[R.f op S.g ](R,S)\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to solve mapping rule ?",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to resolve mapping rule ?",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to mitigate mapping rule ?",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution for mapping rule",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Provide me some Solution for mapping rule",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "mitigation for mapping rule",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to stop mapping rule ?",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to defend mapping rule ?",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to get secured against mapping rule ?",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution, mapping rule",
  "answer": "Selection:\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... R.f \u00a0op\u00a0 val ...\n \u21d2 \u00a0\u00a0 Select[R.f op val](R)\n SELECT \u00a0 ... \u00a0 FROM \u00a0 ... R ... \u00a0 WHERE \u00a0... Cond1,R \u00a0AND\u00a0 Cond2,R ...\n \u21d2 \u00a0\u00a0 Select[Cond1,R & Cond2,R](R)  or  \u21d2 \u00a0\u00a0 Select[Cond1,R](Select[Cond2,R](R))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to solve mapping rule ?",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to resolve mapping rule ?",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to mitigate mapping rule ?",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution for mapping rule",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Provide me some Solution for mapping rule",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "mitigation for mapping rule",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to stop mapping rule ?",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to defend mapping rule ?",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to get secured against mapping rule ?",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution, mapping rule",
  "answer": "Aggregation operators (e.g. MAX, SUM, ...):\n add as new operators in extended RA  e.g. SELECT MAX(age) FROM ... \u00a0\u00a0 \u21d2 \u00a0\u00a0 max(Proj[age](...))\n Sorting (ORDER BY):\n add Sort operator into extended RA \u00a0 (e.g. Sort[+name,-age](...))\n Duplicate elimination (DISTINCT):\n add Uniq operator into extended RA \u00a0 (e.g. Uniq(Proj(...)))\n Grouping (GROUP BY, HAVING):\n add operators into extended RA \u00a0 (e.g. GroupBy, GroupSelect )\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to solve mapping rule ?",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to resolve mapping rule ?",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to mitigate mapping rule ?",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution for mapping rule",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Provide me some Solution for mapping rule",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "mitigation for mapping rule",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to stop mapping rule ?",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to defend mapping rule ?",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "How to get secured against mapping rule ?",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 },
 {
  "question": "Solution, mapping rule",
  "answer": "View example: assuming Employee(id,name,birthdate,salary)\n -- view definition create view OldEmps as select * from Employees where  birthdate < '01-01-1960'; -- view usage select name from OldEmps; yields\n OldEmps \u00a0=\u00a0 Select[birthdate<'01-01-1960'](Employees)\n Projname(OldEmps)  \u21d2 \u00a0\u00a0 Projname(Select[birthdate<'01-01-1960'](Employees))\n",
  "intent": "solution",
  "key_words": [
   "mapping",
   "rule"
  ]
 }
]