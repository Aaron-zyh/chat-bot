[
 {
  "question": "What is week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "What does week 2 lecture mean ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "Tell me something about week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "week 2 lecture",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "Explain week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "Elaborate week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "Can you tell me about week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "What do you know about week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "What can you tell me about week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "I want to know aboutweek 2 lecture",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "Do you have information about week 2 lecture ?",
  "answer": "Catalogs\n",
  "intent": "description",
  "key_words": [
   "week",
   "2",
   "lecture"
  ]
 },
 {
  "question": "What is catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "What does catalog mean ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "Tell me something about catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "catalog",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "Explain catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "Elaborate catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "Can you tell me about catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "What do you know about catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "What can you tell me about catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "I want to know aboutcatalog",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "Do you have information about catalog ?",
  "answer": "Catalogs are tables describing database objects, e.g.\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "intent": "description",
  "key_words": [
   "catalog"
  ]
 },
 {
  "question": "What is postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "What does postgresql catalog mean ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "Tell me something about postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "postgresql catalog",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "Explain postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "Elaborate postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "Can you tell me about postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "What do you know about postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "What can you tell me about postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "I want to know aboutpostgresql catalog",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "Do you have information about postgresql catalog ?",
  "answer": "You can explore the PostgreSQl catalog via psql commands\n \\d gives a list of all tables and views\n \\d Table gives a schema for Table\n \\df gives a list of user-defined functions\n \\df+ Function gives details of Function\n \\ef Function allows you to edit Function\n \\dv gives a list of user-defined views\n \\d+ View gives definition of View\n You can also explore via SQL on the catalog tables\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "catalog"
  ]
 },
 {
  "question": "What is dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What does dbms storage manager mean ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Tell me something about dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "dbms storage manager",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Explain dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Elaborate dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What do you know about dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutdbms storage manager",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Do you have information about dbms storage manager ?",
  "answer": "Levels of DBMS related to storage management:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What is storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "What does storage technology mean ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "Tell me something about storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "storage technology",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "Explain storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "Elaborate storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "Can you tell me about storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "What do you know about storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "What can you tell me about storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "I want to know aboutstorage technology",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "Do you have information about storage technology ?",
  "answer": "Persistent storage is\n large, cheap, relatively slow, accessed in blocks\n used for long-term storage of data\n Computational storage is\n small, expensive, fast, accessed by byte/word\n used for all analysis of data\n Access cost HDD:RAM \u2245 100000:1, e.g.\n 100ms to read block containing two tuples\n 1\u00b5s to compare fields in two tuples\n",
  "intent": "description",
  "key_words": [
   "storage",
   "technology"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What does cost model mean ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Tell me something about cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "cost model",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Explain cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Elaborate cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Can you tell me about cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What do you know about cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What can you tell me about cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "I want to know aboutcost model",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you have information about cost model ?",
  "answer": "Throughout this course, we compare costs of DB operations\n Important aspects in determining cost:\n data is always transferred to/from disk as whole blocks (pages)\n cost of manipulating tuples in memory is negligible\n overall cost determined primarily by #data-blocks read/written\n Complicating factors in determining costs:\n not all page accesses require disk access  (buffer pool)\n tuples typically have variable size  (tuples/page ?)\n More details later ...\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What does file management mean ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Tell me something about file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "file management",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Explain file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Elaborate file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Can you tell me about file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What do you know about file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What can you tell me about file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "I want to know aboutfile management",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Do you have information about file management ?",
  "answer": "Aims of file management subsystem:\n organise layout of data within the filesystem\n handle mapping from database ID to file address\n transfer blocks of data between buffer pool and filesystem\n also attempts to handle file access error problems (retry)\n Builds higher-level operations on top of OS file operations.\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What is file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What does file management mean ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Tell me something about file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "file management",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Explain file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Elaborate file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Can you tell me about file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What do you know about file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What can you tell me about file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "I want to know aboutfile management",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "Do you have information about file management ?",
  "answer": "Typical file operations provided by the operating system:\n fd = open(fileName,mode)\n   // open a named file for reading/writing/appending\n close(fd)\n   // close an open file, via its descriptor nread = read(fd, buf, nbytes)\n   // attempt to read data from file into buffer nwritten = write(fd, buf, nbytes)\n   // attempt to write data from buffer to file\n lseek(fd, offset, seek_type)\n   // move file pointer to relative/absolute file offset\n fsync(fd)\n   // flush contents of file buffers to disk\n",
  "intent": "description",
  "key_words": [
   "file",
   "management"
  ]
 },
 {
  "question": "What is dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "What does dbms file organisation mean ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "Tell me something about dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "dbms file organisation",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "Explain dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "Elaborate dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "Can you tell me about dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "What do you know about dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "What can you tell me about dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "I want to know aboutdbms file organisation",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "Do you have information about dbms file organisation ?",
  "answer": " Different DBMSs make different choices, e.g.\n by-pass the file system and use a raw disk partition\n have a single very large file containing all DB data\n have several large files, with tables spread across them\n have multiple data files, one for each table\n have multiple files for each table\n etc.\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "How is data for DB objects arranged in the file system?",
  "intent": "description",
  "key_words": [
   "dbms",
   "file",
   "organisation"
  ]
 },
 {
  "question": "What is single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What does single-file dbms mean ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Tell me something about single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "single-file dbms",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Explain single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Elaborate single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Can you tell me about single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What do you know about single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What can you tell me about single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "I want to know aboutsingle-file dbms",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Do you have information about single-file dbms ?",
  "answer": "Consider a single file for the entire database (e.g. SQLite)\n Objects are allocated to regions (segments) of the file.\n If an object grows too large for allocated segment, allocate an extension.\n What happens to allocated space when objects are removed?\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What is single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What does single-file dbms mean ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Tell me something about single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "single-file dbms",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Explain single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Elaborate single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Can you tell me about single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What do you know about single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What can you tell me about single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "I want to know aboutsingle-file dbms",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "Do you have information about single-file dbms ?",
  "answer": "Allocating space in Unix files is easy:\n simply seek to the place you want and write the data\n if nothing there already, data is appended to the file\n if something there already, it gets overwritten\n If the seek goes way beyond the end of the file:\n Unix does not (yet) allocate disk space for the \"hole\"\n allocates disk storage only when data is written there\n With the above, a disk/file manager is easy to implement.\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "dbms"
  ]
 },
 {
  "question": "What is single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What does single-file disk manager mean ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Tell me something about single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "single-file disk manager",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Explain single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Elaborate single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What do you know about single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutsingle-file disk manager",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Do you have information about single-file disk manager ?",
  "answer": "Simple disk manager for a single-file database:\n // Disk Manager data/functions\n #define PAGESIZE 2048   // bytes per page\n typedef int PageID;     // PageID is block index\n typedef struct DBdescriptor {\n    char *dbname;     // copy of database name\n    int   fd;         // the database file\n    SpaceTable map;   // map of free/used areas    NameTable names;  // map names to areas + sizes\n    ...\n } *DB;\n typedef struct RelDescriptor {\n    char *relname;    // copy of table name\n    int   start;      // page index of start of table data\n    int   npages;     // number of pages of table data\n    ...\n } *Reln;\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What is single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What does single-file disk manager mean ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Tell me something about single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "single-file disk manager",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Explain single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Elaborate single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What do you know about single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutsingle-file disk manager",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Do you have information about single-file disk manager ?",
  "answer": "// start using DB DB openDatabase(char *name) {    DB db = new(DBdescriptor);\n    db->dbname = strdup(name);\n    db->fd = open(name,O_RDWR);\n    db->map = readSpaceTable(db);\n    db->names = readNameTable(db);\n    return db;\n }\n // stop using DB and update all meta-data\n void closeDatabase(DB db) {\n    writeSpaceTable(db,db->map);\n    writeNameTable(db,db->names);\n    fsync(db->fd);  // ensure that changes reach disk\n    close(db->fd);\n    free(db);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What is single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What does single-file disk manager mean ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Tell me something about single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "single-file disk manager",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Explain single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Elaborate single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What do you know about single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutsingle-file disk manager",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Do you have information about single-file disk manager ?",
  "answer": "// set up struct describing relation\n Reln openRelation(DB db, char *rname) {\n    Reln r = new(RelDescriptor);\n    r->relname = strdup(rname);\n    // get relation data from map tables\n    r->start = ...;\n    r->npages = ...;\n    return r;\n }\n // stop using a relation\n void closeRelation(Reln r) {\n    free(r);\n }\n #define nPages(r)  (r->npages)\n #define makePageID(r,i)  (r->first + i)\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What is single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What does single-file disk manager mean ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Tell me something about single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "single-file disk manager",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Explain single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Elaborate single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What do you know about single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutsingle-file disk manager",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Do you have information about single-file disk manager ?",
  "answer": "// assume that Page = buffer of PageSize bytes\n // assume that PageID = block number in file\n // read page from file into memory buffer\n void get_page(DB db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    read(db->fd, buf, PAGESIZE);\n }\n // write page from memory buffer to file\n void put_page(Db db, PageID p, Page buf) {\n    lseek(db->fd, pageOffset(p), SEEK_SET);\n    write(db->fd, buf, PAGESIZE);\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What is single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What does single-file disk manager mean ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Tell me something about single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "single-file disk manager",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Explain single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Elaborate single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What do you know about single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutsingle-file disk manager",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Do you have information about single-file disk manager ?",
  "answer": "The pageOffset() function uses the DB map\n takes a PageID value\n uses the DB space map\n returns an absolute file offset\n E.g. each table is allocated large contiguous segment of file\n get start address of relation(PageID) from map\n add pageNumber(PageID)*PAGESIZE to give offset\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What is single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What does single-file disk manager mean ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Tell me something about single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "single-file disk manager",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Explain single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Elaborate single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What do you know about single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutsingle-file disk manager",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Do you have information about single-file disk manager ?",
  "answer": "// managing contents of mapping table is complex\n // assume a list of (offset,length,status) tuples\n // allocate n new pages at end of file\n PageID allocate_pages(int n) {\n    int endfile = lseek(db->fd, 0, SEEK_END);\n    addNewEntry(db->map, endfile, n);\n    // note that file itself is not changed\n }\n // drop n pages starting from p\n void deallocate_pages(PageID p, int n) {\n    markUnused(db->map, p, n);\n    // note that file itself is not changed\n }\n",
  "intent": "description",
  "key_words": [
   "single-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What is multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What does multi-file disk manager mean ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Tell me something about multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "multi-file disk manager",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Explain multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Elaborate multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What do you know about multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutmulti-file disk manager",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "Do you have information about multi-file disk manager ?",
  "answer": "Using multiple files (one file per relation) can be easier\n E.g. extending the size of a relation\n",
  "intent": "description",
  "key_words": [
   "multi-file",
   "disk",
   "manager"
  ]
 },
 {
  "question": "What is postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What does postgresql storage manager mean ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "postgresql storage manager",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Elaborate postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql storage manager",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql storage manager ?",
  "answer": "PostgreSQL uses the following file organisation ...\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What is postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What does postgresql storage manager mean ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "postgresql storage manager",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Elaborate postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql storage manager",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql storage manager ?",
  "answer": "Components of storage subsystem:\n mapping from relations to files   (RelFileNode)\n abstraction for open relation pool   (storage/smgr)\n functions for managing files   (storage/smgr/md.c)\n file-descriptor pool   (storage/file)\n PostgreSQL has two basic kinds of files:\n heap files containing data (tuples)\n index files containing index entries\n Note: smgr designed for many storage devices; only mag disk handler used\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "storage",
   "manager"
  ]
 },
 {
  "question": "What is relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What does relation a file mean ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Tell me something about relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "relation a file",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Explain relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Elaborate relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Can you tell me about relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What do you know about relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What can you tell me about relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "I want to know aboutrelation a file",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Do you have information about relation a file ?",
  "answer": "PostgreSQL identifies relation files via their OIDs.\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Global (shared) tables (e.g. pg_database) have\n   spcNode == GLOBALTABLESPACE_OID\n   dbNode == 0\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What is relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What does relation a file mean ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Tell me something about relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "relation a file",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Explain relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Elaborate relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Can you tell me about relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What do you know about relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What can you tell me about relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "I want to know aboutrelation a file",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "Do you have information about relation a file ?",
  "answer": "The relpath function maps RelFileNode to file:\n char *relpath(RelFileNode r)  // simplified\n {\n    char *path = malloc(ENOUGH_SPACE);\n    if (r.spcNode == GLOBALTABLESPACE_OID) {\n      /* Shared system relations live in PGDATA/global */\n      Assert(r.dbNode == 0);\n       sprintf(path, \"%s/global/%u\",\n               DataDir, r.relNode);\n    }\n    else if (r.spcNode == DEFAULTTABLESPACE_OID) {\n      /* The default tablespace is PGDATA/base */\n      sprintf(path, \"%s/base/%u/%u\",\n               DataDir, r.dbNode, r.relNode);\n    }\n    else {\n      /* All other tablespaces accessed via symlinks */\n      sprintf(path, \"%s/pg_tblspc/%u/%u/%u\", DataDir\n               r.spcNode, r.dbNode, r.relNode);\n    }\n    return path;\n }\n",
  "intent": "description",
  "key_words": [
   "relation",
   "a",
   "file"
  ]
 },
 {
  "question": "What is file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What does file descriptor pool mean ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Tell me something about file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "file descriptor pool",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Explain file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Elaborate file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What do you know about file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutfile descriptor pool",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Do you have information about file descriptor pool ?",
  "answer": "Unix has limits on the number of concurrently open files.\n PostgreSQL maintains a pool of open file descriptors:\n to hide this limitation from higher level functions\n to minimise expensive open() operations\n File names are simply strings: typedef char *FileName\n Open files are referenced via: typedef int File\n A File is an index into a table of \"virtual file descriptors\".\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What is file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What does file descriptor pool mean ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Tell me something about file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "file descriptor pool",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Explain file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Elaborate file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What do you know about file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutfile descriptor pool",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Do you have information about file descriptor pool ?",
  "answer": "Interface to file descriptor (pool):\n File FileNameOpenFile(FileName fileName,\n                       int fileFlags, int fileMode);\n      // open a file in the database directory ($PGDATA/base/...)\n File OpenTemporaryFile(bool interXact);\n      // open temp file; flag: close at end of transaction?\n void FileClose(File file);\n void FileUnlink(File file);\n int  FileRead(File file, char *buffer, int amount);\n int  FileWrite(File file, char *buffer, int amount);\n int  FileSync(File file);\n long FileSeek(File file, long offset, int whence);\n int  FileTruncate(File file, long offset);\n Analogous to Unix syscalls open(), close(), read(), write(), lseek(), ...\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What is file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What does file descriptor pool mean ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Tell me something about file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "file descriptor pool",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Explain file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Elaborate file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What do you know about file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutfile descriptor pool",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Do you have information about file descriptor pool ?",
  "answer": "Virtual file descriptors (Vfd)\n physically stored in dynamically-allocated array\n also arranged into list by recency-of-use\n VfdCache[0] holds list head/tail pointers.\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What is file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What does file descriptor pool mean ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Tell me something about file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "file descriptor pool",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Explain file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Elaborate file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What do you know about file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutfile descriptor pool",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "Do you have information about file descriptor pool ?",
  "answer": "Virtual file descriptor records (simplified):\n typedef struct vfd\n {\n     s_short  fd;              // current FD, or VFD_CLOSED if none\n     u_short  fdstate;         // bitflags for VFD's state\n     File     nextFree;        // link to next free VFD, if in freelist\n     File     lruMoreRecently; // doubly linked recency-of-use list\n     File     lruLessRecently;\n     long     seekPos;         // current logical file position\n     char     *fileName;       // name of file, or NULL for unused VFD\n     // NB: fileName is malloc'd, and must be free'd when closing the VFD\n     int      fileFlags;       // open(2) flags for (re)opening the file\n     int      fileMode;        // mode to pass to open(2)\n } Vfd;\n",
  "intent": "description",
  "key_words": [
   "file",
   "descriptor",
   "pool"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "Reminder: PostgreSQL file organisation",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "PostgreSQL stores each table\n in the directory PGDATA/pg_database.oid\n often in multiple files (aka forks)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "Data files   (Oid, Oid.1, ...):\n sequence of fixed-size blocks/pages  (typically 8KB)\n each page contains tuple data and admin data  (see later)\n max size of data files 1GB  (Unix limitation)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "Free space map   (Oid_fsm):\n indicates where free space is in data pages\n \"free\" space is only free after VACUUM   (DELETE simply marks tuples as no longer in use xmax)\n Visibility map   (Oid_vm):\n indicates pages where all tuples are \"visible\"   (visible = accessible to all currently active transactions)\n such pages can be ignored by VACUUM\n also used for index pages, to indicate all index entries visible   (allows index-only scans to be done more efficiently)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "Relation files are identified via pg_class.relfilenode\n most of the time, this is the same as pg_class.oid\n and with forkNum appended, unless it is zero\n The core data structure for this is RelFileNode:\n typedef struct RelFileNode {\n     Oid  spcNode;  // tablespace\n     Oid  dbNode;   // database\n     Oid  relNode;  // relation\n } RelFileNode;\n Some relations have no relfilenode; use pg_filenode.map file\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "The \"magnetic disk storage manager\" (storage/smgr/md.c)\n manages its own pool of open file descriptors (Vfd's)\n may use several Vfd's to access data, if several forks\n manages mapping from PageID to file+offset.\n PostgreSQL PageID values are structured:\n typedef struct\n {\n     RelFileNode rnode;    // which relation/file\n     ForkNumber  forkNum;  // which fork (of reln)\n     BlockNumber blockNum; // which page/block } BufferTag;\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "Access to a block of data proceeds (roughly) as follows:\n // pageID set from pg_catalog tables\n // buffer obtained from Buffer pool\n getBlock(BufferTag pageID, Buffer buf)\n {\n    Vfd vf;  off_t offset;\n    (vf, offset) = findBlock(pageID)\n    lseek(vf.fd, offset, SEEK_SET)\n    vf.seekPos = offset;\n    nread = read(vf.fd, buf, BLOCKSIZE)\n    if (nread < BLOCKSIZE) ... we have a problem\n }\n BLOCKSIZE is a global configurable constant (default: 8192)\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What does file manager mean ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Tell me something about file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "file manager",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Explain file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Elaborate file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What do you know about file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutfile manager",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "Do you have information about file manager ?",
  "answer": "findBlock(BufferTag pageID) returns (Vfd, off_t)\n {\n    offset = pageID.BlockNumber * BLOCKSIZE\n    fileID = relpath(pageID.rnode)\n    if (pageID.forkNum > 0)\n       fileID = fileID+\".\"+pageID.ForkNum\n    if (fileID is not in Vfd pool)\n       fd = allocate new Vfd for this fileID\n    else\n       fd = use Vfd from pool\n    if (offset > fd.fileSize) {\n       fd = allocate new Vfd for next fork\n       offset = offset - fd.fileSize\n    }\n    return (fd, offset)\n }\n",
  "intent": "description",
  "key_words": [
   "file",
   "manager"
  ]
 },
 {
  "question": "What is dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What does dbms parameter mean ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Tell me something about dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "dbms parameter",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Explain dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Elaborate dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Can you tell me about dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What do you know about dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What can you tell me about dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "I want to know aboutdbms parameter",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Do you have information about dbms parameter ?",
  "answer": "Our view of relations in DBMSs:\n a relation is a set of r  tuples, with average size R  bytes\n the tuples are stored in b  data pages on disk\n each page has size B  bytes and contains up to c  tuples\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr , Tw  dominates other costs\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What is dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What does dbms parameter mean ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Tell me something about dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "dbms parameter",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Explain dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Elaborate dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Can you tell me about dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What do you know about dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What can you tell me about dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "I want to know aboutdbms parameter",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "Do you have information about dbms parameter ?",
  "answer": "Typical DBMS/table parameter values:\n Quantity Symbol E.g. Value\n total # tuples r 106\n record size R 128 bytes\n total # pages b 105\n page size B 8192 bytes\n # tuples per page c 60\n page read/write time Tr ,Tw 10 msec\n cost to process\n one page in memory\n - \u2245 0\n Buffer Pool\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "parameter"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": "Aim of buffer pool:\n hold pages read from database files, for possible re-use\n Buffer pool operations:   (both take single PageID argument)\n request_page(pid),   release_page(pid), ...\n Buffer pool data structures:\n Page frames[NBUFS];   FrameData directory[NBUFS];\n Page is byte[BUFSIZE],   FrameData is struct {...}\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": "For each frame, we need to know:   (FrameData)\n which Page it contains, or whether empty/free\n whether it has been modified since loading (dirty bit)\n how many transactions are currently using it (pin count)\n time-stamp for most recent access (assists with replacement)\n which page = PageID = (RelationID,PageNum)    (note: Page = Block)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    getBlock(pageID, buf);\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n }\n Requires N page reads.\n If we read it again, N page reads.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How scans are performed without Buffer Pool?",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": " Buffer buf;\n int N = numberOfBlocks(Rel);\n for (i = 0; i < N; i++) {\n    pageID = makePageID(db,Rel,i);\n    bufID = request_page(pageID);\n    buf = frames[bufID]\n    for (j = 0; j < nTuples(buf); j++)\n       process(buf, j)\n    release_page(pageID);\n }\n Requires N page reads on the first pass.\n If we read it again, 0 \u2264 page reads \u2264 N\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How scans are performed with Buffer Pool?",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": "Implementation of request_page()\n int request_page(PageID pid)\n {\n    if (pid in Pool)\n       bufID = index for pid in Pool\n    else {\n       if (no free frames in Pool)\n          evict a page (free a frame)\n       bufID = allocate free frame\n       directory[bufID].page = pid\n       directory[bufID].pin_count = 0\n       directory[bufID].dirty_bit = 0\n    }\n    directory[bufID].pin_count++\n    return bufID\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": "Implementation of release_page()\n int release_page(PageID pid)\n {\n    bufID = index for pid in Pool\n    directory[bufID].pin_count--\n }\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does buffer pool mean ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "buffer pool",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Elaborate buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about buffer pool ?",
  "answer": "Evicting a page ...\n find frame(s) preferably satisfying\n pin count = 0   (i.e. nobody using it)\n dirty bit = 0   (not modified)\n if selected frame was modified, flush frame to disk\n flag directory entry as \"frame empty\"\n If multiple frames can potentially be released\n need a policy to decide which is best choice\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What does page replacement policy mean ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Tell me something about page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "page replacement policy",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Explain page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Elaborate page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Can you tell me about page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What do you know about page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What can you tell me about page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "I want to know aboutpage replacement policy",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Do you have information about page replacement policy ?",
  "answer": "Several schemes are commonly in use:\n Least Recently Used (LRU)\n Most Recently Used (MRU)\n First in First Out (FIFO)\n Random\n LRU / MRU require knowledge of when pages were last accessed\n how to keep track of \"last access\" time?\n base on request/release ops or on real page usage?\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What is page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What does page replacement policy mean ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Tell me something about page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "page replacement policy",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Explain page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Elaborate page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Can you tell me about page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What do you know about page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What can you tell me about page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "I want to know aboutpage replacement policy",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "Do you have information about page replacement policy ?",
  "answer": "Cost benefit from buffer pool (with n frames) is determined by:\n number of available frames (more \u21d2 better)\n replacement strategy vs page access pattern\n Example (a): sequential scan, LRU or MRU, n \u2265 b\n First scan costs b reads; subsequent scans are \"free\".\n Example (b): sequential scan, MRU, n < b\n First scan costs b reads; subsequent scans cost b - n reads.\n Example (c): sequential scan, LRU, n < b\n All scans cost b reads; known as sequential flooding.\n",
  "intent": "description",
  "key_words": [
   "page",
   "replacement",
   "policy"
  ]
 },
 {
  "question": "What is effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What does effect of buffer management mean ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Tell me something about effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "effect of buffer management",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Explain effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Elaborate effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Can you tell me about effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What do you know about effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What can you tell me about effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "I want to know abouteffect of buffer management",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Do you have information about effect of buffer management ?",
  "answer": "Consider a query to find customers who are also employees:\n select c.name\n from   Customer c, Employee e\n where  c.ssn = e.ssn;\n This might be implemented inside the DBMS via nested loops:\n for each tuple t1 in Customer {\n     for each tuple t2 in Employee {\n         if (t1.ssn == t2.ssn)\n             append (t1.name) to result set\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What is effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What does effect of buffer management mean ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Tell me something about effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "effect of buffer management",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Explain effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Elaborate effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Can you tell me about effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What do you know about effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What can you tell me about effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "I want to know abouteffect of buffer management",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "Do you have information about effect of buffer management ?",
  "answer": "In terms of page-level operations, the algorithm looks like:\n Rel rC = openRelation(\"Customer\");\n Rel rE = openRelation(\"Employee\");\n for (int i = 0; i < nPages(rC); i++) {\n     PageID pid1 = makePageID(db,rC,i);\n     Page p1 = request_page(pid1);\n     for (int j = 0; j < nPages(rE); j++) {\n         PageID pid2 = makePageID(db,rE,j);\n         Page p2 = request_page(pid2);\n         // compare all pairs of tuples from p1,p2\n         // construct solution set from matching pairs\n         release_page(pid2);\n     }\n     release_page(pid1);\n }\n",
  "intent": "description",
  "key_words": [
   "effect",
   "of",
   "buffer",
   "management"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "postgresql buffer manager",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Elaborate postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions:  src/include/storage/buf*.h\n Functions:  src/backend/storage/buffer/*.c\n Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "postgresql buffer manager",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Elaborate postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of 8KB frames\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "postgresql buffer manager",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Elaborate postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "postgresql buffer manager",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Elaborate postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n Produced: 2 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 }
]