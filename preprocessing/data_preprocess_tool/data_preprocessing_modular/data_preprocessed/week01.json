[
 {
  "topic": "COMP9315 18S2\n",
  "content": "DBMS Implementation\n ( Data structures and algorithms inside relational DBMSs )\n Lecturer: \u00a0 John Shepherd\n",
  "key_words": [
   "comp9315"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Web Site\n",
  "content": "http://www.cse.unsw.edu.au/~cs9315/\n (If WebCMS unavailable, use http://www.cse.unsw.edu.au/~cs9315/18s2/)\n",
  "key_words": [
   "web",
   "site"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Lecturer 2/98\n",
  "content": "Name: John Shepherd\n Office: K17-410 (turn right from lift)\n Phone: 9385 6494\n Email: jas@cse.unsw.edu.au\n Consult: Mon 2-3, Wed 11-12 \u00a0 (in K17-410)\n Research: Information Extraction/Integration  Information Retrieval/Web Search  e-Learning Technologies  Multimedia Databases  Query Processing\n",
  "key_words": [
   "lecturer"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Course Admin 3/98\n",
  "content": "Name: Jashank Jeremy\n Email: cs9315@cse.unsw.edu.au   (email goes to both Jashank and me)\n Reasons: Enrolment problems  Special consideration  Detailed assignment questions  Technical issues\n",
  "key_words": [
   "course",
   "admin"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Course Goals 4/98\n",
  "content": "Introduce you to:\n architecture(s) of relational DBMSs \u00a0(via PostgreSQL)\n algorithms/data-structures for data-intensive computing\n representation of relational database objects\n representation of relational operators (sel,proj,join)\n techniques for processing SQL queries\n techniques for managing concurrent transactions\n concepts in non-relational databases\n Develop skills in:\n analysing the performance of data-intensive algorithms\n the use of C to implement data-intensive algorithms\n",
  "key_words": [
   "course",
   "goal"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Learning/Teaching 5/98\n",
  "content": " Textbooks: describe some syllabus topics in detail\n Notes: describe all syllabus topics in some detail\n Lecture slides: summarise Notes and contain exercises\n Lecture videos: for review or if you miss a lecture, or are in WEB stream\n Readings: research papers on selected topics\n The onus is on you to use this material.\n  Note: Lecture slides, exercises and videos will be available only after the lecture.\n",
  "key_words": [
   "learning",
   "teaching"
  ],
  "question": [
   "What's available for you?"
  ],
  "intent_tag": "unknow"
 },
 {
  "topic": "... Learning/Teaching 6/98\n",
  "content": "Things that you need to do:\n Exercises: tutorial-like questions\n Prac work: lab-class-like exercises\n Assignments: large/important practical exercises\n On-line quizzes: for self-assessment\n Dependencies:\n Exercises \u2192 Exam (theory part)\n Prac work \u2192 Assignments \u2192 Exam (prac part)\n There are no tute/lab classes; use Forum, Email, Consultations\n debugging is best done in person \u00a0(where full environment is visible)\n",
  "key_words": [
   "learning",
   "teaching"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Rough Schedule 7/98\n",
  "content": "Week 01 intro, dbms review, dbms architecture\n Week 02 storage: disks, buffers, pages\n Week 03 RA ops: scan, sort, projection\n Week 04 selection: heaps, hashing, indexes\n Week 05 no lectures\n Week 06 selection: N-d matching, similarity\n Week 07 joins: naive, sort-merge, hash join\n Week 08 query processing, optimisation\n Week 09 transactions: concurrency, recovery\n \"Mid\"-term no lectures\n Week 10 distributed and non-SQL databases\n",
  "key_words": [
   "rough",
   "schedule"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Textbooks 8/98\n",
  "content": "No official text book; several are suitable ...\n Garcia-Molina, Ullman, Widom  \"Database Systems: The Complete Book\"\n Ramakrishnan, Gehrke  \"Database Systems Management\"\n Silberschatz, Korth, Sudarshan  \"Database System Concepts\"\n Kifer, Bernstein, Lewis  \"Database Systems: An algorithmic-oriented approach\"\n Elmasri, Navathe  \"Database Systems: Models, languages, design ...\"\n but not all cover all topics in detail\n",
  "key_words": [
   "textbook"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Pre-requisites 9/98\n",
  "content": "We assume that you are already familiar with\n the C language and programming in C (or C++)  \u00a0 (e.g. completed an intro programming course in C)\n developing applications on RDBMSs  \u00a0 (SQL, [relational algebra] \u00a0 e.g. an intro DB course)\n basic ideas about file organisation and file manipulation  \u00a0 (Unix open, close, lseek, read, write, flock)\n sorting algorithms, data structures for searching  \u00a0 (sorting, trees, hashing \u00a0 e.g. a data structures course)\n If you don't know this material, you will struggle to pass ...\n",
  "key_words": [
   "pre-requisites"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Exercise 1: SQL (revision) 10/98\n",
  "content": "Given the following schema:\n Students(sid, name, degree, ...) e.g. Students(3322111, 'John Smith', 'MEngSc', ...) Courses(cid, code, term, title, ...) e.g. Courses(1732, 'COMP9311', '12s1', 'Databases', ...) Enrolments(sid, cid, mark, grade) e.g. Enrolments(3322111, 1732, 50, 'PS') Write an SQL query to solve the problem\n find all students who passed COMP9315 in 18s2\n for each student, give (student ID, name, mark)\n",
  "key_words": [
   "exercise",
   "1",
   "sql",
   "(revision)"
  ],
  "question": null,
  "intent_tag": "exercise"
 },
 {
  "topic": "Exercise 2: Unix File I/O (revision) 11/98\n",
  "content": "Write a C program that reads a file, block-by-block.\n Command-line parameters:\n block size in bytes\n name of input file\n Use low-level C operations: open, read.\n Count and display how many blocks/bytes read.\n",
  "key_words": [
   "exercise",
   "2",
   "unix",
   "file",
   "i",
   "o",
   "(revision)"
  ],
  "question": null,
  "intent_tag": "exercise"
 },
 {
  "topic": "Prac Work 12/98\n",
  "content": "In this course, we use PostgreSQL v10.4 \u00a0 (compulsory)\n Prac Work requires you to compile PostgreSQL from source code\n instructions explain how to do this on Linux at CSE\n also works easily on Linux and Mac OSX at home\n PostgreSQL docs describe how to compile for Windows\n Make sure you do the first Prac Exercise when it becomes available.\n Sort out any problems ASAP (preferably at a consultation).\n",
  "key_words": [
   "prac",
   "work"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Prac Work 13/98\n",
  "content": "PostgreSQL is a large software system:\n > 1700 source code files in the core engine/clients\n > 1,000,000 lines of C code in the core\n You won't be required to understand all of it :-)\n You will need to learn to navigate this code effectively.\n Will discuss relevant parts in lectures to help with this.\n PostgreSQL books?\n tend to add little to the manual, and cost a lot\n",
  "key_words": [
   "prac",
   "work"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Assignments 14/98\n",
  "content": "Schedule of assignment work:\n Ass Description Due Marks\n 1 Storage Management Week 5 10%\n 2 Query Processing Week 10 15%\n Assignments will be carried out in pairs (see WebCMS).\n Choose own online tools to share code (e.g. git, DropBox).\n Ultimately, submission is via CSE's give system.\n Will spend some time in lectures reviewing assignments.\n Assignments will require up-front code-reading (see Pracs).\n",
  "key_words": [
   "assignment"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Assignments 15/98\n",
  "content": "Don't leave assignments to the last minute\n they require significant code reading\n as well as code writing and testing\n and, you can submit early.\n \"Carrot\": bonus marks are available for early submissions.\n \"Stick\": marks deducted (from max) for late submissions.\n",
  "key_words": [
   "assignment"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Quizzes 16/98\n",
  "content": "Over the course of the semester ...\n six online quizzes\n taken in your own time (but there are deadlines)\n each quiz is worth a small number of marks\n Quizzes are primarily a review tool to check progress.\n But they contribute 15% of your overall mark for the course.\n",
  "key_words": [
   "quiz"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Exam 17/98\n",
  "content": "Three-hour exam in the November exam period.\n Held in the CSE Labs, but mainly a written (typed) Exam.\n The Course Notes (only) will be available in the exam.\n Things that we can't reasonably test in the exam:\n writing large programs, running major experiments\n Everything else is potentially examinable.\n Contains: descriptive questions, analysis, small programming exercises.\n Exam contributes 60% of the overall mark for this course.\n",
  "key_words": [
   "exam"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Exam 18/98\n",
  "content": "If you cannot attend the final exam ...\n because of documented illness/misadventure\n and you have reasonable marks in Ass+Quiz\n then you will be offered a Supplementary Exam.\n There is no other way to get a Supp Exam.\n You get one chance at passing the exam\n make sure you're fit and healthy on exam day\n score more than 24/60 (which is only 40%)\n",
  "key_words": [
   "exam"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Assessment Summary 19/98\n",
  "content": "Your final mark/grade is computed according to the following:\n ass1   = mark for assignment 1      (out of 10) ass2   = mark for assignment 2      (out of 15) quiz   = mark for on-line quizzes   (out of 15) exam   = mark for final exam        (out of 60) okExam = exam > 24/60           (after scaling)  mark   = ass1 + ass2 + quiz + exam grade  = HD|DN|CR|PS,  if mark \u2265 50 && okExam        = FL,           if mark < 50 && okExam        = UF,           if !okExam Relational Database Revision\n",
  "key_words": [
   "assessment",
   "summary"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Relational DBMS Functionality 21/98\n",
  "content": "Relational DBMSs provide a variety of functionalities:\n storing/modifying data and meta-data \u00a0(data defintions)\n constraint definition/storage/maintenance/checking\n declarative manipulation of data (via SQL)\n extensibility via views, triggers, stored procedures\n query re-writing (rules), optimisation (indexes)\n transaction processing, concurrency/recovery\n etc. etc. etc.\n Common feature of all relational DBMSs: relational model, SQL.\n",
  "key_words": [
   "relational",
   "dbms",
   "functionality"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Data Definition 22/98\n",
  "content": "Relational data: relations/tables, tuples, values, types, e.g.\n  create domain WAMvalue float    check (value between 0.0 and 100.0);  create table Students (    id          integer,  -- e.g. 3123456    familyName  text,     -- e.g. 'Smith'    givenName   text,     -- e.g. 'John'    birthDate   date,     -- e.g. '1-Mar-1984'    wam         WAMvalue, -- e.g. 85.4    primary key (id) ); The above adds meta-data to the database.\n DBMSs typically store meta-data as special tables (catalog).\n",
  "key_words": [
   "data",
   "definition"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Data Definition 23/98\n",
  "content": "Input: DDL statement \u00a0 (e.g. create table)\n Result: meta-data in catalog is modified\n",
  "key_words": [
   "data",
   "definition"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Data Definition 24/98\n",
  "content": "Constraints are an important aspect of data definition:\n attribute (column) constraints\n tuple constraints\n relation (table) constraints\n referential integrity constraints\n Examples:\n create table Employee (    id      integer primary key,    name    varchar(40),    salary  real,    age     integer check (age > 15),    worksIn integer references Department(id),    constraint PayOk check (salary > age*1000) ); On each attempt to change data, DBMS checks constraints.\n",
  "key_words": [
   "data",
   "definition"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Data Modification 25/98\n",
  "content": "Critical function of DBMS: changing data\n insert new tuples into tables\n delete existing tuples from tables\n update values within existing tuples\n E.g.\n insert into Enrolments(student,course,mark) values (3312345, 5542, 75);  update Enrolments set mark = 77 where  student = 3354321 and course = 5542;  delete Enrolments where student = 3112233;",
  "key_words": [
   "data",
   "modification"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Data Modification 26/98\n",
  "content": "Input: DML statements\n Result: tuples are added, removed or modified\n",
  "key_words": [
   "data",
   "modification"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Query Evaluator 27/98\n",
  "content": "Most common function of relational DBMSs\n read an SQL query\n return a table giving result of query\n E.g.\n select s.id, c.code, e.mark from   Students s, Courses c, Enrolments e where  s.id = e.student and e.course = c.id;",
  "key_words": [
   "query",
   "evaluator"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Query Evaluator 28/98\n",
  "content": "Input: SQL query\n Output: table (displayed as text)\n",
  "key_words": [
   "query",
   "evaluator"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "DBMS Architecture 29/98\n",
  "content": "The aim of this course is to\n look inside the DBMS box\n discover the various mechanisms it uses\n understand and analyse their performance\n Why should we care? (apart from passing the exam)\n Practical reason:\n if we understand how query processor works,  we can do a better job of writing efficient queries\n Educational reason:\n DBMSs contain interesting data structures + algorithms  which may be useful outside the (relational) DBMS context\n",
  "key_words": [
   "dbms",
   "architecture"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... DBMS Architecture 30/98\n",
  "content": "Path of a query through a typical DBMS:\n",
  "key_words": [
   "dbms",
   "architecture"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... DBMS Architecture 31/98\n",
  "content": "",
  "key_words": [
   "dbms",
   "architecture"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... DBMS Architecture 32/98\n",
  "content": "Important factors related to DBMS architecture\n data is stored permanently on large slow devices**\n data is processed in small fast memory\n Implications:\n data structures should minimise storage utilisation\n algorithms should minimise memory/disk data transfers\n Modern DBMSs interact with storage via the O/S file-system.\n  ** SSDs change things a little, but most high volume bulk storage still on disks\n",
  "key_words": [
   "dbms",
   "architecture"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Database Engine Operations 33/98\n",
  "content": "DB engine = \"relational algebra virtual machine\":\n selection (\u03c3) projection (\u03c0) join (\u22c8)\n union (\u222a) intersection (\u2229) difference (-)\n sort group aggregate\n For each of these operations:\n various data structures and algorithms are available\n DBMSs may provide only one, or may provide a choice\n",
  "key_words": [
   "database",
   "engine",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Relational Algebra 34/98\n",
  "content": "Relational algebra (RA) can be viewed as ...\n mathematical system for manipulating relations, or\n data manipulation language (DML) for the relational model\n Core relational algebra operations:\n selection: choosing a subset of rows\n projection: choosing a subset of columns\n product, join: combining relations\n union, intersection, difference: combining relations\n rename: change names of relations/attributes\n Common extensions include:\n sorting (order by), partition (group by), aggregation\n",
  "key_words": [
   "relational",
   "algebra"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Relational Algebra 35/98\n",
  "content": "All RA operators return a result of type relation.\n For convenience, we can name a result and use it later.\n E.g. database \u00a0 R1(x,y), \u00a0 R2(y,z), \u00a0\n  Tmp1(x,y)   = Sel[x>5]R1 Tmp2(y,z)   = Sel[z=3]R2 Tmp3(x,y,z) = Tmp1 Join Tmp2 Res(x,z)    = Proj[x,z] Tmp3 -- which is equivalent to Res(x,z)    = Proj[x,z]((Sel[x>5]R1) Join (Sel[z=3]R2)) -- which is equivalent to Tmp1(x,y,z) = R1 Join R2 Tmp2(x,y,z) = Sel[x>5 & z=3] Tmp1 Res(x,z)    = Proj[x,z]Tmp2 Each \"intermediate result\" has a well-defined schema.\n",
  "key_words": [
   "relational",
   "algebra"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Exercise 3: Relational Algebra 36/98\n",
  "content": "Using the same student/course/enrolment schema as above:\n Students(sid, name, degree, ...) Courses(cid, code, term, title, ...) Enrolments(sid, cid, mark, grade) Write relational algebra expressions to solve the problem\n find all students who passed COMP9315 in 18s2\n for each student, give (student ID, name, mark)\n",
  "key_words": [
   "exercise",
   "3",
   "relational",
   "algebra"
  ],
  "question": null,
  "intent_tag": "exercise"
 },
 {
  "topic": "Describing Relational Algebra Operations 37/98\n",
  "content": "We define the semantics of RA operations using\n \"conditional set\" expressions \u00a0 e.g. { x | condition }\n tuple notations:\n t[ab] \u00a0 (extracts attributes a and b from tuple t)\n (x,y,z) \u00a0 (enumerated tuples; specify attribute values)\n quantifiers, set operations, boolean operators\n Notation: r(R) means relation instance r based on schema R\n",
  "key_words": [
   "describing",
   "relational",
   "algebra",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Relational Algebra Operations 38/98\n",
  "content": "Selection\n \u03c3C(r) \u00a0 = \u00a0 Sel[C](r) \u00a0 = \u00a0 { t \u00a0|\u00a0 t \u2208 r \u2227 C(t) }\n C is a boolean function that tests selection condition\n Computational view:\n result = {} for each tuple t in relation r     if (C(t)) { result = result \u222a {t} }",
  "key_words": [
   "relational",
   "algebra",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Relational Algebra Operations 39/98\n",
  "content": "Projection\n \u03c0X(r) \u00a0 = \u00a0 Proj[X](r) \u00a0 = \u00a0 { t[X] \u00a0|\u00a0 t \u2208 r }\n X \u2286 R ; \u00a0result schema is given by attributes in X\n Computational view:\n result = {} for each tuple t in relation r     result = result \u222a {t[X]}",
  "key_words": [
   "relational",
   "algebra",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Relational Algebra Operations 40/98\n",
  "content": "Set operations involve two relations r(R), s(R) \u00a0 (union-compatible)\n Union\n r1 \u222a r2 \u00a0 = \u00a0 { t \u00a0|\u00a0 t \u2208 r1 \u2228 t \u2208 r2 }, \u00a0\u00a0\u00a0 where r1(R), r2(R)\n Computational view:\n result = r1 for each tuple t in relation r2     result = result \u222a {t}",
  "key_words": [
   "relational",
   "algebra",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Relational Algebra Operations 41/98\n",
  "content": "Intersection\n r1 \u2229 r2 \u00a0 = \u00a0 { t \u00a0|\u00a0 t \u2208 r1 \u2227 t \u2208 r2 }, \u00a0\u00a0\u00a0 where r1(R), r2(R)\n Computational view:\n result = {} for each tuple t in relation r1     if (t \u2208 r2) { result = result \u222a {t} }",
  "key_words": [
   "relational",
   "algebra",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Relational Algebra Operations 42/98\n",
  "content": "Theta Join\n r \u22c8C s \u00a0 = \u00a0 Join[C](r,s) \u00a0 =  \u00a0\u00a0\u00a0 { (t1 : t2) \u00a0|\u00a0 t1 \u2208 r \u2227 t2 \u2208 s \u2227 C(t1 : t2) }, where r(R),s(S)\n C is the join condition (involving attributes from both relations)\n Computational view:\n result = {} for each tuple t1 in relation r    for each tuple t2 in relation s       if (matches(t1,t2,C))          result = result \u222a {concat(t1,t2)}",
  "key_words": [
   "relational",
   "algebra",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Relational Algebra Operations 43/98\n",
  "content": "Left Outer Join\n JoinLO[C](R,S) includes entries for all R tuples\n even if they have no matches with tuples in S under C\n Computational description of r(R)\u00a0LeftOuterJoin\u00a0s(S):\n result = {} for each tuple t1 in relation r    nmatches = 0    for each tuple t2 in relation s       if (matches(t1,t2,C))          result = result \u222a {combine(t1,t2)}          nmatches++    if (nmatches == 0)       result = result \u222a {combine(t1,Snull)} where Snull is a tuple with schema S and all atributes set to NULL.\n PostgreSQL\n",
  "key_words": [
   "relational",
   "algebra",
   "operation"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "PostgreSQL 45/98\n",
  "content": "PostgreSQL is a full-featured open-source (O)RDBMS.\n provides a relational engine with:\n efficient implementation of relational operations\n very good transaction processing (concurrent access)\n good backup/recovery (from application/system failure)\n novel query optimisation (genetic algorithm-based)\n replication, JSON, extensible indexing, etc. etc.\n already supports several non-standard data types\n allows users to define their own data types\n supports most of the SQL3 standard\n",
  "key_words": [
   "postgresql"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "PostgreSQL Online 46/98\n",
  "content": "Web site: www.postgresql.org\n Key developers: Bruce Momjian, Tom Lane, Marc Fournier, ...\n Full list of developers: www.postgresql.org/developer/bios\n Local copy of source code:\n http://www.cse.unsw.edu.au/~cs9315/18s2/postgresql/src.tar.bz2\n Documentation is available via WebCMS menu.\n",
  "key_words": [
   "postgresql",
   "online"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "User View of PostgreSQL 47/98\n",
  "content": "Users interact via SQL in a client process, e.g.\n  $ psql webcms psql (10.4) Type \"help\" for help. webcms2=# select * from calendar;  id | course |   evdate   |      event ----+--------+------------+---------------------------   1 |      4 | 2001-08-09 | Project Proposals due  10 |      3 | 2001-08-01 | Tute/Lab Enrolments Close  12 |      3 | 2001-09-07 | Assignment #1 Due (10pm)  ... or\n  $dbconn = pg_connect(\"dbname=webcms\"); $result = pg_query($dbconn,\"select * from calendar\"); while ($tuple = pg_fetch_array($result))    { ... $tuple[\"event\"] ... }",
  "key_words": [
   "user",
   "view",
   "of",
   "postgresql"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "PostgreSQL Functionality 48/98\n",
  "content": "PostgreSQL systems deal with various kinds of entities:\n users ... who can use the system, what they can do\n groups ... groups of users, for role-based privileges\n databases ... collections of schemas/tables/views/...\n namespaces ... to uniquely identify objects (schema.table.attr)\n tables ... collection of tuples (standard relational notion)\n views ... \"virtual\" tables (can be made updatable)\n functions ... operations on values from/in tables\n triggers ... operations invoked in response to events\n operators ... functions with infix syntax\n aggregates ... operations over whole table columns\n types ... user-defined data types (with own operations)\n rules ... for query rewriting (used e.g. to implement views)\n access methods ... efficient access to tuples in tables\n",
  "key_words": [
   "postgresql",
   "functionality"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Functionality 49/98\n",
  "content": "PostgreSQL's dialect of SQL is mostly standard (but with extensions).\n attributes containing arrays of atomic values\n create table R ( id integer, values integer[] ); insert into R values ( 123, '{5,4,3,2,1}' ); table type inheritance\n create table S ( x float, y float); create table T inherits ( R, S ); table-valued functions\n create function f(integer) returns setof TupleType;",
  "key_words": [
   "postgresql",
   "functionality"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Functionality 50/98\n",
  "content": "PostgreSQL stored procedures differ from SQL standard:\n only provides functions, not procedures  (but functions can return void, effectively a procedure)\n allows function overloading  (same function name, different argument types)\n defined at different \"lexical level\" to SQL\n provides own PL/SQL-like language for functions\n create function ( ArgTypes ) returns ResultType as $$ ... body of function definition ... $$ language FunctionBodyLanguage;",
  "key_words": [
   "postgresql",
   "functionality"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Functionality 51/98\n",
  "content": "Example:\n create or replace function     barsIn(suburb text) returns setof Bars as $$ declare     r record; begin     for r in         select * from Bars where location = suburb     loop        return next r;     end loop; end; $$ language plpgsql; used as e.g. select * from barsIn('Randwick');",
  "key_words": [
   "postgresql",
   "functionality"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Functionality 52/98\n",
  "content": "Uses multi-version concurrency control (MVCC)\n multiple \"versions\" of the database exist together\n a transaction sees the version that was valid at its start-time\n readers don't block writers; writers don't block readers\n this significantly reduces the need for locking\n Disadvantages of this approach:\n extra storage for old versions of tuples \u00a0 (vacuum fixes this)\n  PostgreSQL also provides locking to enforce critical concurrency.\n",
  "key_words": [
   "postgresql",
   "functionality"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Functionality 53/98\n",
  "content": "PostgreSQL has a well-defined and open extensibility model:\n stored procedures are held in database as strings\n allows a variety of languages to be used\n language interpreters can be integrated into engine\n can add new data types, operators, aggregates, indexes\n typically requires code written in C, following defined API\n for new data types, need to write input/output functions, ...\n for new indexes, need to implement file structures\n",
  "key_words": [
   "postgresql",
   "functionality"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "PostgreSQL Architecture 54/98\n",
  "content": "Client/server architecture:\n  The listener process is sometimes called postmaster\n",
  "key_words": [
   "postgresql",
   "architecture"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Architecture 55/98\n",
  "content": "Memory/storage architecture:\n",
  "key_words": [
   "postgresql",
   "architecture"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Architecture 56/98\n",
  "content": "File-system architecture:\n",
  "key_words": [
   "postgresql",
   "architecture"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Exercise 4: PostgreSQL Data Files 57/98\n",
  "content": "PostgreSQL uses OIDs as\n the name of the directory for each database\n the name of the files for each table\n Using the pg_catalog tables, find ..\n the directory for the pizza database\n the data files for the Pizzas and People tables\n Relevant catalog info ...\n pg_database(oid,datname,...) pg_class(oid,relname,...)",
  "key_words": [
   "exercise",
   "4",
   "postgresql",
   "data",
   "file"
  ],
  "question": null,
  "intent_tag": "exercise"
 },
 {
  "topic": "Installing PostgreSQL 58/98\n",
  "content": "PostgreSQL is available via the COMP9315 web site.\n Provided as tar-file in ~cs9315/web/18s2/postgresql/\n File: src.tar.bz2 is ~15MB **\n Unpacked, source code is ~130MB **\n If using on CSE, do not put it under your home directory\n Place it under /srvr/YOU/ which has 500MB quota\n  ** Smaller than \"normal\" PG distribution ... documentation removed\n",
  "key_words": [
   "installing",
   "postgresql"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Installing PostgreSQL 59/98\n",
  "content": "Environment setup for running PostgreSQL in COMP9315:\n # Must be \"source\"d from sh, bash, ksh, ...  # can be any directory PGHOME=/home/jas/srvr/pgsql # data does not need to be under $PGHOME export PGDATA=$PGHOME/data export PGHOST=$PGDATA export PGPORT=5432 export PATH=$PGHOME/bin:$PATH  alias p0=\"$D/bin/pg_ctl stop\" alias p1=\"$D/bin/pg_ctl -l $PGDATA/log start\" Will probably work (with tweaks) on home laptop if Linux or MacOS\n",
  "key_words": [
   "installing",
   "postgresql"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Installing PostgreSQL 60/98\n",
  "content": "Brief summary of installation:\n $ tar xfj ..../postgresql/src.tar.bz2   # create a directory postgresql-10.4 $ source ~/your/environment/file   # set up environment variables $ configure --prefix=$PGHOME $ make $ make install $ initdb   # set up postgresql configuration ... done once? $ edit postgresql.conf $ pg_ctl start -l $PGDATA/log   # do some work with PostgreSQL databases $ pg_ctl stop On CSE machines, ~cs9315/bin/pgs can simplify some things\n",
  "key_words": [
   "installing",
   "postgresql"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Using PostgreSQL for Assignments 61/98\n",
  "content": "If changes don't modify storage structures ...\n $ edit source code $ pg_ctl stop $ make $ make install $ pg_ctl start -l $PGDATA/log   # run tests, analyse results, ... $ pg_ctl stop In this case, existing databases will continue to work ok.\n",
  "key_words": [
   "using",
   "postgresql",
   "for",
   "assignment"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Using PostgreSQL for Assignments 62/98\n",
  "content": "If changes modify storage structures ...\n $ edit source code $ save a copy of postgresql.conf $ pg_dump testdb > testdb.dump $ pg_ctl stop $ make $ make install $ rm -fr $PGDATA $ initdb $ restore postgresql.conf $ pg_ctl start -l $PGDATA/log $ createdb testdb $ psql testdb -f testdb.dump   # run tests and analyse results Old databases will not work with the new server.\n",
  "key_words": [
   "using",
   "postgresql",
   "for",
   "assignment"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Using PostgreSQL for Assignments 63/98\n",
  "content": "Troubleshooting ...\n read the $PGDATA/log file\n which socket file are you trying to connect to?\n check the $PGDATA directory for socket files\n remove postmster.pid if sure no server running\n ...\n Prac Exercise P01 has useful tips down the bottom\n",
  "key_words": [
   "using",
   "postgresql",
   "for",
   "assignment"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "PostgreSQL Source Code 64/98\n",
  "content": "Top-level of PostgreSQL distribution contains:\n README,INSTALL: \u00a0 overview and installation instructions\n config*: \u00a0 scripts to build localised Makefiles\n Makefile: \u00a0 top-level script to control system build\n src: \u00a0 sub-directories containing system source code\n doc: \u00a0 FAQs and documentation (removed to save space)\n contrib: \u00a0 source code for contributed extensions\n",
  "key_words": [
   "postgresql",
   "source",
   "code"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Source Code 65/98\n",
  "content": "The source code directory (src) contains:\n include: \u00a0 *.h files with global definitions (constants, types, ...)\n backend: \u00a0 code for PostgreSQL database engine\n bin: \u00a0 code for clients (e.g. psql, pg_ctl, pg_dump, ...)\n pl: \u00a0 stored procedure language interpreters (e.g. plpgsql)\n interfaces \u00a0 code for low-level C interfaces (e.g. libpq)\n along with Makefiles to build system and other directories ...\n Code for backend (DBMS engine)\n ~1700 files (~1000.c, ~700.h, 8.y, 10.l), \u00a0 106 lines of code\n",
  "key_words": [
   "postgresql",
   "source",
   "code"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Source Code 66/98\n",
  "content": " become familiar with the user-level interface\n psql, pg_dump, pg_ctl\n start with the *.h files, then move to *.c files\n *.c files live under src/backend/*\n *.h files live under src/include)\n start globally, then work one subsystem-at-a-time\n Some helpful information is available via:\n PostgreSQL Doco link on web site\n Readings link on web site\n",
  "key_words": [
   "postgresql",
   "source",
   "code"
  ],
  "question": [
   "How to get started understanding the workings of PostgreSQL?"
  ],
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Source Code 67/98\n",
  "content": "PostgreSQL documentation has detailed description of internals:\n Section VII, Chapters 50 - 68\n Ch.60 is an overview; a good place to start\n other chapters discuss specific components\n See also \"How PostgreSQL Processes a Query\"\n src/tools/backend/index.html\n",
  "key_words": [
   "postgresql",
   "source",
   "code"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... PostgreSQL Source Code 68/98\n",
  "content": "exec_simple_query(const char *query_string)\n defined in src/backend/tcop/postgres.c\n entry point for evaluating SQL queries\n assumes query_string is one or more SQL statements\n  parsetree_list = pg_parse_query(query_string); foreach(parsetree, parsetree_list) {   querytree_list = pg_analyze_and_rewrite(parsetree, ...);   plantree_list = pg_plan_queries(querytree_list, ...);   portal = CreatePortal(...); // query execution env   PortalDefineQuery(portal, ..., plantree_list, ...);   receiver = CreateDestReceiver(dest); // client   PortalRun(portal, ..., receiver, ...);   ... } Storage Management\n",
  "key_words": [
   "postgresql",
   "source",
   "code"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Storage Management 70/98\n",
  "content": "Aims of storage management in DBMS:\n provide view of data as collection of tables/tuples\n map from database objects (e.g. tables) to disk files\n manage transfer of data to/from disk storage\n use buffers to minimise disk/memory transfers\n interpret loaded data as tuples/records\n give foundation for file structures used by access methods\n",
  "key_words": [
   "storage",
   "management"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Management 71/98\n",
  "content": "Levels of DBMS related to storage management:\n",
  "key_words": [
   "storage",
   "management"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Views of Data 72/98\n",
  "content": "Users and top-level query evaluator see data as\n a collection of tables, each with a schema (tuple-type)\n where each table contains a set (sequence) of tuples\n ",
  "key_words": [
   "view",
   "of",
   "data"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Views of Data 73/98\n",
  "content": "Relational operators and access methods see data as\n sequence of fixed-size pages, typically 1KB to 8KB\n where each page contains tuple data or index data\n",
  "key_words": [
   "view",
   "of",
   "data"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Views of Data 74/98\n",
  "content": "File manager sees both DB objects and file store\n maps (tableName, pageIndex) to (file, offset)\n",
  "key_words": [
   "view",
   "of",
   "data"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Storage Management Topics 75/98\n",
  "content": "Topics to be considered:\n DB Object Management (Catalog)\n how tables/functions/types, etc. are represented\n Disks and Files\n performance issues and organisation of disk files\n Buffer Management\n using caching to improve DBMS system throughput\n Tuple/Page Management\n how tuples are represented within disk pages\n Each topic illustrated by its PostgreSQL implementation.\n",
  "key_words": [
   "storage",
   "management",
   "topic"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Storage Manager Interface 76/98\n",
  "content": "The storage manager provides higher levels of system\n with an abstraction based on relations/pages/tuples\n which maps down to files/blocks/records (via buffers)\n Example: simple scan of a relation:\n select student,course from Enrolments High-level view of result: sequence of tuples.\n How is this mapped to accesses to files/blocks/records?\n",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 77/98\n",
  "content": "The query:\n select student, course from Enrolments; (Roughly) how it's executed:\n DB db = openDatabase(\"myDB\"); Reln r = openRel(db,\"Enrolments\"); Scan s = startScan(r); Tuple t;  Results res = NULL; while ((t = nextTuple(s)) != NULL) {     int stuid = getField(t,\"student\");     char *course = getField(t,\"course\");     res = addTuple(res, mkTuple(stuid,course)); }",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 78/98\n",
  "content": "",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 79/98\n",
  "content": "The storage manager provides mechanisms for:\n representing database objects during query execution\n DB (handle on an authorised/opened database)\n Reln (handle on an opened relation)\n Page (memory buffer to hold contents of data block)\n Tuple (memory holding data values from one tuple)\n referring to database objects (addresses)\n symbolic (e.g. database/schema/table/field names)\n abstract physical (e.g. PageId, TupleId)\n",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 80/98\n",
  "content": "Examples of references (addresses) used in DBMSs:\n PageID ... identifies (locates) a block of data\n typically, PageID = FileID + Offset\n where Offset gives location of block within file\n TupleID ... identifies (locates) a single tuple\n typically, TupleID = PageID + Offset\n where Offset gives location of tuple within page\n Note that Offsets may be indexes into mapping tables giving real address.\n",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 81/98\n",
  "content": "Possible implementation for DB object ...\n typedef struct Database {    char    *name; // database name    Catalog  cat;  // meta-data    ... } *DB; Possible implementation of Reln object ...\n typedef struct Relation {    char    *name; // table name    File     file; // fd for table file    ... } *Reln;",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 82/98\n",
  "content": "Possible implementation for Scan object ...\n query executor wants to see result tuple-at-a-time\n DBMS read blocks from files (page-of-tuples-at-a-time)\n typedef struct ScanData {    File  file;   // file holding table data    Page  page;   // most recently read data    int   pageno; // current block within file    int   tupno;  // current tuple within page    ... } *Scan;",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 83/98\n",
  "content": "startScan() might be implemented as:\n Scan startScan(Reln r) {    Scan s = MemAlloc(struct ScanData);    s->file = r->file;    s->page = null;    s->pageno = 0;    s->tupno = 0;    return s; }",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Storage Manager Interface 84/98\n",
  "content": "And nextTuple() might be implemented as:\n Tuple nextTuple(Scan s) {    if (noMoreTuplesIn(s->page,s->tupno))       if (noMorePagesIn(s->file))          return NULL;       s->page = getPage(s->file,s->pageno);       s->pageno++;       s->tupno = 0;    }    Tuple t = getTuple(s->page,s->tupno);    s->tupno++;    return t; }",
  "key_words": [
   "storage",
   "manager",
   "interface"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "From Symbolic to Internal 85/98\n",
  "content": " information about a database, given its name\n information about a table, given its name\n DBMSs use catalog data in special tables\n E.g. for PostgreSQL\n  pg_database(oid, datname, datdba, datacl[], ...) pg_namespace(oid, nspname, nspowner, nspacl[], ...) pg_class(oid, relname, relnamespace, ..., relkind,          reltuples, relnatts, relhaspkey, relacl[] ...) pg_attribute(oid, attrelid, attname, atttypid, attnum, ...) pg_type(oid, typname, typnamespace, typowner, typlen, ...) Catalogs\n",
  "key_words": [
   "from",
   "symbolic",
   "to",
   "internal"
  ],
  "question": [
   "How do we determine ?"
  ],
  "intent_tag": "unknow"
 },
 {
  "topic": "Database Objects 87/98\n",
  "content": "RDBMSs manage different kinds of objects\n databases, schemas, tablespaces\n relations/tables, attributes, tuples/records\n constraints, assertions\n views, stored procedures, triggers, rules\n Many objects have names (and, in PostgreSQL, all have OIDs).\n How are the different types of objects represented?\n How do we go from a name (or OID) to bytes stored on disk?\n",
  "key_words": [
   "database",
   "object"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Database Objects 88/98\n",
  "content": "Consider what information the RDBMS needs about relations:\n name, owner, primary key of each relation\n name, data type, constraints for each attribute\n authorisation for operations on each relation\n Similarly for other DBMS objects (e.g. views, functions, triggers, ...)\n This information is stored in the system catalog tables\n Standard for catalogs in SQL:2003: INFORMATION_SCHEMA\n",
  "key_words": [
   "database",
   "object"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Database Objects 89/98\n",
  "content": "The catalog is affected by several types of SQL operations:\n create Object as Definition\n drop Object ...\n alter Object \u00a0 Changes\n grant Privilege on Object\n where Object is one of table, view, function, trigger, schema, ...\n E.g. drop table Groups; produces something like\n delete from Tables where  schema = 'public' and name = 'groups';",
  "key_words": [
   "database",
   "object"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Database Objects 90/98\n",
  "content": "In PostgreSQL, the system catalog is available to users via:\n special commands in the psql shell (e.g. \\d)\n SQL standard information_schema   e.g. select * from information_schema.tables;\n  The low-level representation is available to sysadmins via:\n a global schema called pg_catalog\n a set of tables/views in that schema (e.g. pg_tables)\n",
  "key_words": [
   "database",
   "object"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Database Objects 91/98\n",
  "content": "A PostgreSQL installation (cluster) typically has many DBs\n Some catalog information is global, e.g.\n catalog tables defining: databases, users, ...\n one copy of each such table for the whole PostgreSQL installation\n shared by all databases in the cluster (in PGDATA/pg_global)\n Other catalog information is local to each database, e.g\n schemas, tables, attributes, functions, types, ...\n separate copy of each \"local\" table in each database\n a copy of many \"global\" tables is made on database creation\n",
  "key_words": [
   "database",
   "object"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Database Objects 92/98\n",
  "content": "Side-note: \u00a0 PostgreSQL tuples contain\n owner-specified attributes (from create table)\n system-defined attributes\n oid unique identifying number for tuple (optional)\n tableoid which table this tuple belongs to\n xmin/xmax which transaction created/deleted tuple (for MVCC)\n OIDs are used as primary keys in many of the catalog tables.\n",
  "key_words": [
   "database",
   "object"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Representing Databases 93/98\n",
  "content": "Above the level of individual DB schemata, we have:\n databases ... represented by pg_database\n schemas ... represented by pg_namespace\n table spaces ... represented by pg_tablespace\n These tables are global to each PostgreSQL cluster.\n Keys are names (strings) and must be unique within cluster.\n",
  "key_words": [
   "representing",
   "database"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Representing Databases 94/98\n",
  "content": "pg_database contains information about databases:\n oid, datname, datdba, datacl[], encoding, ...\n pg_namespace contains information about schemata:\n oid, nspname, nspowner, nspacl[]\n pg_tablespace contains information about tablespaces:\n oid, spcname, spcowner, spcacl[]\n PostgreSQL represents access via array of access items:\n Role=Privileges/Grantor where Privileges is a string enumerating privileges, e.g.\n jas=arwdRxt/jas,fred=r/jas,joe=rwad/jas",
  "key_words": [
   "representing",
   "database"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Representing Tables 95/98\n",
  "content": "Representing one table needs tuples in several catalog tables.\n Due to O-O heritage, base table for tables is called pg_class.\n The pg_class table also handles other \"table-like\" objects:\n views ... represents attributes/domains of view\n composite (tuple) types ... from CREATE TYPE AS\n sequences, indexes (top-level defn), other \"special\" objects\n All tuples in pg_class have an OID, used as primary key.\n Some fields from the pg_class table:\n oid, relname, relnamespace, reltype, relowner\n relkind, reltuples, relnatts, relhaspkey, relacl, ...\n",
  "key_words": [
   "representing",
   "table"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "... Representing Tables 96/98\n",
  "content": "Details of catalog tables representing database tables\n pg_class holds core information about tables\n relname, relnamespace, reltype, relowner, ...\n relkind, relnatts, relhaspkey, relacl[], ...\n pg_attribute contains information about attributes\n attrelid, attname, atttypid, attnum, ...\n pg_type contains information about types\n typname, typnamespace, typowner, typlen, ...\n typtype, typrelid, typinput, typoutput, ...\n",
  "key_words": [
   "representing",
   "table"
  ],
  "question": null,
  "intent_tag": "unknow"
 },
 {
  "topic": "Exercise 5: Table Statistics 97/98\n",
  "content": "Using the PostgreSQL catalog, write a PLpgSQL function\n to return table name and #tuples in table\n for all tables in the public schema\n create type TableInfo as (table text, ntuples int); create function pop() returns setof TableInfo ... Hint: you will need to use dynamically-generated queries.\n",
  "key_words": [
   "exercise",
   "5",
   "table",
   "statistic"
  ],
  "question": null,
  "intent_tag": "exercise"
 },
 {
  "topic": "Exercise 6: Extracting a Schema 98/98\n",
  "content": "Write a PLpgSQL function:\n function schema() returns setof text\n giving a list of table schemas in the public schema\n It should behave as follows:\n db=# select * from schema();             tables ---------------------------  table1(x, y, z)  table2(a, b)  table3(id, name, address) ... Produced: 26 Jul 2018\n",
  "key_words": [
   "exercise",
   "6",
   "extracting",
   "a",
   "schema"
  ],
  "question": null,
  "intent_tag": "exercise"
 }
]