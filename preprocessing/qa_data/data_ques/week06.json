[
 {
  "question": "What is week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "What is week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "What does week 6 lecture mean ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "Tell me something about week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "Explain week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "Can you tell me about week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "What do you know about week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "What can you tell me about week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "I want to know aboutweek 6 lecture",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "Do you have information about week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "Do you know week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "what about week 6 lecture ?",
  "answer": "Implementing in PostgreSQL\n",
  "intent": "description",
  "key_words": [
   "week",
   "6",
   "lecture"
  ]
 },
 {
  "question": "What is recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "What is recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "What does recap on implementing selection mean ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "Tell me something about recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "Explain recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "Can you tell me about recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "What do you know about recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "What can you tell me about recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "I want to know aboutrecap on implementing selection",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "Do you have information about recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "Do you know recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "what about recap on implementing selection ?",
  "answer": "Selection =  select * from  R  where  C\n yields a subset of R tuples satisfying condition C\n a very important (frequent) operation in relational databases\n Types of selection determined by type of condition\n one:  select * from  R  where id=k\n pmr:  select * from  R  where age=65\n rng:   select * from  R  where age\u226518 and age\u226421\n Strategies for implementing selection efficiently\n arrangement of tuples in file  (e.g. sorting, hashing)\n auxiliary data structures  (e.g. indexes, signatures)\n",
  "intent": "description",
  "key_words": [
   "recap",
   "on",
   "implementing",
   "selection"
  ]
 },
 {
  "question": "What is linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What does linear hashing mean ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Tell me something about linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Explain linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Can you tell me about linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What do you know about linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What can you tell me about linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "I want to know aboutlinear hashing",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you have information about linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you know linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "what about linear hashing ?",
  "answer": "File organisation:\n file of primary data blocks\n file of overflow data blocks\n a register called the split pointer\n Uses systematic method of growing data file ...\n hash function \"adapts\" to changing address range\n systematic splitting controls length of overflow chains\n",
  "intent": "description",
  "key_words": [
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What does insertion with linear hashing mean ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Tell me something about insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Explain insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Can you tell me about insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What do you know about insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What can you tell me about insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "I want to know aboutinsertion with linear hashing",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you have information about insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you know insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "what about insertion with linear hashing ?",
  "answer": "Abstract view:\n P = bits(d,hash(key));\n if (P < sp) P = bits(d+1,hash(key));\n // bucket P = page P + its overflow pages\n for each page Q in bucket P {\n     if (space in Q) { insert into Q; break; }\n }\n if (no insertion) {\n     add new ovflow page to bucket P\n     insert into new page\n }\n if (need to split) {\n     partition tuples from bucket sp\n           into buckets sp and sp+2^d\n     sp++;\n     if (sp == 2^d) { d++; sp = 0; }\n }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What does insertion with linear hashing mean ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Tell me something about insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Explain insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Can you tell me about insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What do you know about insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What can you tell me about insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "I want to know aboutinsertion with linear hashing",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you have information about insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you know insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "what about insertion with linear hashing ?",
  "answer": "Splitting block sp=01:\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What does insertion with linear hashing mean ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Tell me something about insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Explain insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Can you tell me about insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What do you know about insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What can you tell me about insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "I want to know aboutinsertion with linear hashing",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you have information about insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you know insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "what about insertion with linear hashing ?",
  "answer": "Splitting algorithm:\n // partitions tuples between two buckets\n newp = sp + 2^d; oldp = sp;\n buf = getPage(f,sp);\n clear(oldBuf); clear(newBuf);\n // start filling data page buffers\n for (i = 0; i < nTuples(buf); i++) {\n     tup = getTuple(buf,i);\n     p = bits(d+1,hash(tup.k));\n     if (p == newp)         addTuple(newBuf,tup);\n     else\n         addTuple(oldBuf,tup);\n }\n ... remove and re-insert tuples from ovflow chain ...\n sp++;\n if (sp == 2^d) { d++; sp = 0; }\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What is insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What does insertion cost mean ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Tell me something about insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Explain insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Can you tell me about insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What do you know about insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What can you tell me about insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "I want to know aboutinsertion cost",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Do you have information about insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Do you know insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "what about insertion cost ?",
  "answer": "If no split required, cost same as for standard hashing:\n Costinsert  =    Best: 1r + 1w,     Worst: (1+max(Ov))r + 2w\n If split occurs, incur Costinsert  plus cost of splitting:\n read block sp   (plus all of its overflow blocks)\n write block sp   (and its new overflow blocks)\n write block sp+2d   (and its new overflow blocks)\n On average,   Costsplit  =  (1+Ov)r + (2+Ov)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What is deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What does deletion with linear hashing mean ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Tell me something about deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Explain deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Can you tell me about deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What do you know about deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What can you tell me about deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "I want to know aboutdeletion with linear hashing",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you have information about deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "Do you know deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "what about deletion with linear hashing ?",
  "answer": "Deletion is similar to ordinary static hash file.\n But might wish to contract file when enough tuples removed.\n Rationale: r shrinks, b stays large \u21d2 wasted space.\n Method: remove last bucket in data file (contracts linearly).\n Involves a coalesce procedure which is an inverse split.\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "linear",
   "hashing"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does hash file in postgresql mean ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know abouthash file in postgresql",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about hash file in postgresql ?",
  "answer": "PostgreSQL uses linear hashing on tables which have been:\n create index Ix on R using hash (k);\n Hash file implementation: backend/access/hash\n hashfunc.c ... a family of hash functions\n hashinsert.c ... insert, with overflows\n hashpage.c ... utilities + splitting\n hashsearch.c ... iterator for hash files\n Based on \"A New Hashing Package for Unix\", Margo Seltzer, Winter Usenix 1991\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does hash file in postgresql mean ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know abouthash file in postgresql",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about hash file in postgresql ?",
  "answer": "PostgreSQL uses a different file organisation ...\n has a single file containing main and overflow pages\n has groups of size 2n of data pages\n in between groups, arbitrary number of overflow pages\n maintains collection of group pointers in header page\n each group pointer indicates start of data page group\n Also maintain a split pointer for data pages.\n If overflow pages become empty, add to free list and re-use.\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does hash file in postgresql mean ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know abouthash file in postgresql",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about hash file in postgresql ?",
  "answer": "PostgreSQL hash file structure:\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does hash file in postgresql mean ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know abouthash file in postgresql",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about hash file in postgresql ?",
  "answer": "Converting bucket # to page address (adapted from pgsql source):\n typedef unsigned int Word;\n // which page is primary page of bucket B\n Word bucket_to_page(Word splits[], B) {\n    Word chunk, base, offset;\n    chunk = (B<2) ? 0 : lg2(B+1)-1;\n    base = splits[chunk];\n    offset = (B<2) ? B : B-(1<<chunk);\n    return (base + offset);\n }\n // returns ceil(log_2(n))\n int lg2(Word n) {\n    int i, v;\n    for (i = 0, v = 1; v < n; v <= 1) i++;\n    return i;\n }\n",
  "intent": "description",
  "key_words": [
   "hash",
   "file",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "What is indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "What does indexing mean ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "Tell me something about indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "Explain indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "Can you tell me about indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "What do you know about indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "What can you tell me about indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "I want to know aboutindexing",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "Do you have information about indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "Do you know indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "what about indexing ?",
  "answer": "An index is a table/file of (keyVal,tupleID) pairs, e.g.\n",
  "intent": "description",
  "key_words": [
   "indexing"
  ]
 },
 {
  "question": "What is index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What is index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What does index mean ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Tell me something about index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Explain index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Can you tell me about index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What do you know about index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What can you tell me about index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "I want to know aboutindex",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Do you have information about index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Do you know index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "what about index ?",
  "answer": "A 1-d index is based on the value of a single attribute A.\n Some possible properties of A:\n may be used to sort data file   (or may be sorted on some other field)\n values may be unique   (or there may be multiple instances)\n Taxonomy of index types, based on properties of index attribute:\n primary index on unique field, may be sorted on A\n clustering index on non-unique field, file sorted on A\n secondary file not sorted on A\n A given table may have indexes on several attributes.\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What is index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What is index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What does index mean ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Tell me something about index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Explain index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Can you tell me about index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What do you know about index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What can you tell me about index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "I want to know aboutindex",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Do you have information about index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "Do you know index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "what about index ?",
  "answer": "Indexes themselves may be structured in several ways:\n dense every tuple is referenced by an entry in the index file\n sparse only some tuples are referenced by index file entries\n single-level tuples are accessed directly from the index file\n multi-level may need to access several index pages to reach tuple\n Index file has total i pages   (where typically i \u226a b)\n Index file has page capacity ci   (where typically ci \u226b c)\n Dense index:  i = ceil( r/ci )     Sparse index:  i = ceil( b/ci )\n",
  "intent": "description",
  "key_words": [
   "index"
  ]
 },
 {
  "question": "What is dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "What does dense primary index mean ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "Tell me something about dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "Explain dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "What do you know about dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutdense primary index",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you have information about dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you know dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "what about dense primary index ?",
  "answer": "Data file unsorted; one index entry for each tuple\n",
  "intent": "description",
  "key_words": [
   "dense",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "What does sparse primary index mean ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "Tell me something about sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "Explain sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "What do you know about sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutsparse primary index",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you have information about sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you know sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "what about sparse primary index ?",
  "answer": "Data file sorted; one index entry for each page\n",
  "intent": "description",
  "key_words": [
   "sparse",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What does selection with primary index mean ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Tell me something about selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Explain selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What do you know about selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutselection with primary index",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you have information about selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you know selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "what about selection with primary index ?",
  "answer": "For one queries:\n ix = binary search index for entry with key K\n if nothing found { return NotFound }\n b = getPage(pageOf(ix.tid))\n t = getTuple(b,offsetOf(ix.tid))\n    -- may require reading overflow pages\n return t\n Worst case:   read log2i index pages  +  read 1+Ov data pages.\n Thus, Costone,prim  =  log2 i + 1 + Ov\n Assume: index pages are same size as data pages \u21d2 same reading cost\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What does selection with primary index mean ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Tell me something about selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Explain selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What do you know about selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutselection with primary index",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you have information about selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you know selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "what about selection with primary index ?",
  "answer": "For range queries on primary key:\n use index search to find lower bound\n read index sequentially until reach upper bound\n accumulate set of buckets to be examined\n examine each bucket in turn to check for matches\n For pmr queries involving primary key:\n search as if performing one query.\n For queries not involving primary key, index gives no help.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What does insertion with primary index mean ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Tell me something about insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Explain insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What do you know about insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutinsertion with primary index",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you have information about insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you know insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "what about insertion with primary index ?",
  "answer": "Overview:\n insert tuple into page P\n find location for new entry in index file\n    // could check whether it already exists\n insert new index entry (k,tid) into index file    // tid = tupleID = (P + offset within page)\n Problem: order of index entries must be maintained\n need to avoid overflow pages in index\n so we need to reorganise index file\n On average, this requires us to read/write half of index file.\n Costinsert,prim  =  (log2i)r + i/2.(1r+1w) + (1+Ov)r + (1+\u03b4)w\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What does deletion with primary index mean ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Tell me something about deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Explain deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What do you know about deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutdeletion with primary index",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you have information about deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "Do you know deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "what about deletion with primary index ?",
  "answer": "Overview:\n find tuple using index\n mark tuple as deleted\n delete index entry for tuple\n If we delete index entries by marking ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + 2w\n If we delete index entry by index file reorganisation ...\n Costdelete,prim  =  (log2 i + 1 + Ov)r + i/2.(1r+1w) + 1w\n",
  "intent": "description",
  "key_words": [
   "deletion",
   "with",
   "primary",
   "index"
  ]
 },
 {
  "question": "What is clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What is clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What does clustering index mean ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Tell me something about clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Explain clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Can you tell me about clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What do you know about clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What can you tell me about clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "I want to know aboutclustering index",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Do you have information about clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Do you know clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "what about clustering index ?",
  "answer": "Data file sorted; one index entry for each key value\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What is clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What is clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What does clustering index mean ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Tell me something about clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Explain clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Can you tell me about clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What do you know about clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What can you tell me about clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "I want to know aboutclustering index",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Do you have information about clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "Do you know clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "what about clustering index ?",
  "answer": "Index on non-unique ordering attribute Ac.\n Usually a sparse index; one pointer to first tuple containing value.\n Assists with:\n range queries on Ac   (find lower bound, then scan data)\n pmr queries involving Ac   (search index for specified value)\n Insertions are expensive: rearrange index file and data file.\n Deletions relatively cheap (similar to primary index).\n (Note: can't mark index entry for value X until all X tuples are deleted)\n",
  "intent": "description",
  "key_words": [
   "clustering",
   "index"
  ]
 },
 {
  "question": "What is secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What is secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What does secondary index mean ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Tell me something about secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Explain secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What do you know about secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutsecondary index",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Do you have information about secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Do you know secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "what about secondary index ?",
  "answer": "Generally, dense index on non-unique attribute As\n data file is not ordered on attribute As\n index file is ordered on attribute As\n Problem: multiple tuples with same value for As.\n A solution:\n dense index (Ix2) containing just TupleId's\n sparse index (Ix1) on dense index containing (key,offset) pairs\n Each offset references an entry in Ix2\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What is secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What is secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What does secondary index mean ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Tell me something about secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Explain secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What do you know about secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutsecondary index",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Do you have information about secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "Do you know secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "what about secondary index ?",
  "answer": "Costpmr  =  Costrange  =  (log2i + aq2 + bq.(1 + Ov)) Costrange  =  (log2i + aq1 + aq2 + bq.(1 + Ov))\n",
  "intent": "description",
  "key_words": [
   "secondary",
   "index"
  ]
 },
 {
  "question": "What is insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "What is insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "What does insertion deletion with secondary index mean ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "Tell me something about insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "Explain insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "Can you tell me about insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "What do you know about insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "What can you tell me about insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "I want to know aboutinsertion deletion with secondary index",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "Do you have information about insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "Do you know insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "what about insertion deletion with secondary index ?",
  "answer": "Insertion:\n each insert requires three files to be updated\n potentially costly rearrangement of index files\n Deletion:\n use mark-style (tombstone) deletion for data tuples\n Ix2 entries: can always mark as \"deleted\"\n Ix1 entries: mark only after removing last instance for k in Ix2\n periodic \"vacuum\" to reduce storage overhead if many deletions\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "deletion",
   "with",
   "secondary",
   "index"
  ]
 },
 {
  "question": "What is multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What is multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What does multi-level index mean ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Tell me something about multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Explain multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Can you tell me about multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What do you know about multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What can you tell me about multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "I want to know aboutmulti-level index",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Do you have information about multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Do you know multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "what about multi-level index ?",
  "answer": "Above Secondary Index used two index files to speed up search\n by keeping the initial index search relatively quick\n Ix1 small (depends on number of unique key values)\n Ix2 larger (depends on amount of repetition of keys)\n typically, bIx1 \u226a bIx2\n Could improve further by\n making Ix1 sparse, since Ix2 is guaranteed to be ordered\n in this case, bIx1 = ceil( bIx2 / ci )\n if Ix1 becomes too large, add Ix3 and make Ix2 sparse\n if data file ordered on key, could make Ix3 sparse\n Ultimately, reduce top-level of index hierarchy to one page.\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What is multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What is multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What does multi-level index mean ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Tell me something about multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Explain multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Can you tell me about multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What do you know about multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What can you tell me about multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "I want to know aboutmulti-level index",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Do you have information about multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Do you know multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "what about multi-level index ?",
  "answer": "Example data file with three-levels of index:\n Assume:  not primary key,  c = 100,  ci = 3\n",
  "intent": "description",
  "key_words": [
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What is select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What is select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What does select with multi-level index mean ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Tell me something about select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Explain select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Can you tell me about select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What do you know about select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What can you tell me about select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "I want to know aboutselect with multi-level index",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Do you have information about select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "Do you know select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "what about select with multi-level index ?",
  "answer": "For one query on indexed key field:\n I = top level index page\n for level = 1 to d {\n     read index page I\n     search index page for J'th entry\n         where index[J].key <= K < index[J+1].key\n     if J=0 { return NotFound }\n     I = index[J].page\n }\n -- I is now address of data page\n search page I and its overflow pages\n Read d index blocks and 1+Ov data blocks.\n Thus, Costone,mli  =  (d + 1 + Ov)r\n (Note that d = ceil( logci r ) and ci is large because index entries are small)\n",
  "intent": "description",
  "key_words": [
   "select",
   "with",
   "multi-level",
   "index"
  ]
 },
 {
  "question": "What is b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What is b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What does b-trees mean ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Tell me something about b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Explain b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Can you tell me about b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What do you know about b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What can you tell me about b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "I want to know aboutb-trees",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Do you have information about b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Do you know b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "what about b-trees ?",
  "answer": "B-trees are MSTs with the properties:\n they are updated so as to remain balanced\n each node has at least (n-1)/2 entries in it\n each tree node occupies an entire disk page\n B-tree insertion and deletion methods\n are moderately complicated to describe\n can be implemented very efficiently\n Advantages of B-trees over general MSTs\n better storage utilisation (around 2/3 full)\n better worst case performance (shallower)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What is b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What is b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What does b-trees mean ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Tell me something about b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Explain b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Can you tell me about b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What do you know about b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What can you tell me about b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "I want to know aboutb-trees",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Do you have information about b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "Do you know b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "what about b-trees ?",
  "answer": "Example B-tree (depth=3, n=3):\n (Note that nodes are pages, with potential for large branching factor, e.g. n=500)\n",
  "intent": "description",
  "key_words": [
   "b-trees"
  ]
 },
 {
  "question": "What is b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "What is b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "What does b-tree depth mean ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "Tell me something about b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "Explain b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "Can you tell me about b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "What do you know about b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "What can you tell me about b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "I want to know aboutb-tree depth",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "Do you have information about b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "Do you know b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "what about b-tree depth ?",
  "answer": "Depth depends on effective branching factor  (i.e. how full nodes are).\n Simulation studies show typical B-tree nodes are 69% full.\n Gives   load Li = 0.69 \u00d7 ci   and   depth of tree ~ ceil( logLi r ).\n Example: ci=128,    Li=88\n Level #nodes #keys\n root 1 87\n 1 88 7656\n 2 7744 673728\n 3 681472 59288064\n Note: ci is generally larger than 128 for a real B-tree.\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "depth"
  ]
 },
 {
  "question": "What is insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "What is insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "What does insertion into b-trees mean ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "Tell me something about insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "Explain insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "Can you tell me about insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "What do you know about insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "What can you tell me about insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "I want to know aboutinsertion into b-trees",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "Do you have information about insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "Do you know insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "what about insertion into b-trees ?",
  "answer": "Overview of the method:\n 1. find leaf node and position in node where entry would be stored\n 2. if node is not full, insert entry into appropriate spot\n 3. if node is full, split node into two half-full nodes\n                        and promote middle element to parent\n 4. if parent full, split and promote\n Note: if duplicates not allowed and key is found, may stop after step 1.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "b-trees"
  ]
 },
 {
  "question": "What is example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "What is example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "What does example b-tree insertion mean ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "Tell me something about example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "Explain example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "Can you tell me about example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "What do you know about example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "What can you tell me about example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "I want to know aboutexample b-tree insertion",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "Do you have information about example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "Do you know example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "what about example b-tree insertion ?",
  "answer": "https://www.youtube.com/watch?v=KdbFmwRvkvg\n",
  "intent": "description",
  "key_words": [
   "example",
   "b-tree",
   "insertion"
  ]
 },
 {
  "question": "What is b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What is b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What does b-tree insertion cost mean ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Tell me something about b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Explain b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Can you tell me about b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What do you know about b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What can you tell me about b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "I want to know aboutb-tree insertion cost",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Do you have information about b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Do you know b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "what about b-tree insertion cost ?",
  "answer": "Insertion cost = CosttreeSearch + CosttreeInsert + CostdataInsert\n Best case: write one page (most of time)\n traverse from root to leaf\n read/write data page, write updated leaf\n Costinsert  =  Dr + 1w + 1r + 1w\n Common case: 3 node writes (rearrange 2 leaves + parent)\n traverse from root to leaf, holding nodes in buffer\n read/write data page\n update/write leaf, parent and sibling\n Costinsert  =  Dr + 3w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What is b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What is b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What does b-tree insertion cost mean ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Tell me something about b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Explain b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Can you tell me about b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What do you know about b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What can you tell me about b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "I want to know aboutb-tree insertion cost",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Do you have information about b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "Do you know b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "what about b-tree insertion cost ?",
  "answer": "Worst case: 2D-1 node writes (propagate to root)\n traverse from root to leaf, holding nodes in buffers\n read/write data page\n update/write leaf, parent and sibling\n repeat previous step D-1 times\n Costinsert  =  Dr + (2D-1)w + 1r + 1w\n",
  "intent": "description",
  "key_words": [
   "b-tree",
   "insertion",
   "cost"
  ]
 },
 {
  "question": "What is selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "What is selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "What does selection with b-trees mean ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "Tell me something about selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "Explain selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "Can you tell me about selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "What do you know about selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "What can you tell me about selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "I want to know aboutselection with b-trees",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "Do you have information about selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "Do you know selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "what about selection with b-trees ?",
  "answer": "For one queries:\n N = B-tree root node\n while (N is not a leaf node)\n    N = scanToFindChild(N,K)\n TupleID = scanToFindEntry(N,K)\n access tuple t using TupleID from N\n Costone  =  (D + 1)r\n For range queries (assume sorted on index attribute):\n search index to find leaf node for Lo\n for each leaf node entry until Hi found {\n  access tuple t using TupleId from entry\n }\n Costrange  =  (D + bi + bq)r\n",
  "intent": "description",
  "key_words": [
   "selection",
   "with",
   "b-trees"
  ]
 },
 {
  "question": "What is b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does b-trees in postgresql mean ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know aboutb-trees in postgresql",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about b-trees in postgresql ?",
  "answer": "PostgreSQL implements Lehman/Yao-style B-trees.\n A variant that works effectively in high-concurrency environments.\n B-tree implementation: backend/access/nbtree\n nbtree.c ... interface functions (for iterators)\n nbtsearch.c ... traverse index to find key value\n nbtinsert.c ... add new entry to B-tree index\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does b-trees in postgresql mean ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know aboutb-trees in postgresql",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about b-trees in postgresql ?",
  "answer": "Interface functions for B-trees\n // build Btree index on relation\n Datum btbuild(rel,index,...)\n // insert index entry into Btree\n Datum btinsert(rel,key,tupleid,index,...)\n // start scan on Btree index\n Datum btbeginscan(rel,key,scandesc,...)\n // get next tuple in a scan\n Datum btgettuple(scandesc,scandir,...)\n // close down a scan\n Datum btendscan(scandesc)\n N-dimensional Selection\n",
  "intent": "description",
  "key_words": [
   "b-trees",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "What is n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "What does n-dimensional query mean ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "Tell me something about n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "Explain n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "Can you tell me about n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "What do you know about n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "What can you tell me about n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "I want to know aboutn-dimensional query",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "Do you have information about n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "Do you know n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "what about n-dimensional query ?",
  "answer": "Have looked at one-dimensional queries, e.g.\n select * from R where a = K\n select * from R where a between Lo and Hi\n and heaps, hashing, indexing as ways of efficient implementation.\n Now consider techniques for efficient multi-dimensional queries.\n Compared to 1-d queries, multi-dimensional queries\n typically produce fewer results\n require us to consider more information\n require more effort to produce results\n",
  "intent": "description",
  "key_words": [
   "n-dimensional",
   "query"
  ]
 },
 {
  "question": "What is operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "What is operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "What does operation for nd select mean ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "Tell me something about operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "Explain operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "Can you tell me about operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "What do you know about operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "What can you tell me about operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "I want to know aboutoperation for nd select",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "Do you have information about operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "Do you know operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "what about operation for nd select ?",
  "answer": "N-dimensional select queries = condition on \u22651 attributes.\n pmr = partial-match retrieval (equality tests), e.g.\n select * from Employees\n where  job = 'Manager' and gender = 'M';\n space = tuple-space queries (range tests), e.g.\n select * from Employees\n where 20 \u2264 age \u2264 50 and 40K \u2264 salary \u2264 60K\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "nd",
   "select"
  ]
 },
 {
  "question": "What is n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "What is n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "What does n-d selection via heap mean ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "Tell me something about n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "Explain n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "Can you tell me about n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "What do you know about n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "What can you tell me about n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "I want to know aboutn-d selection via heap",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "Do you have information about n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "Do you know n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "what about n-d selection via heap ?",
  "answer": "Heap files can handle pmr or space using standard method:\n // select * from R where C\n r = openRelation(\"R\",READ);\n for (p = 0; p < nPages(r); p++) {\n     buf = getPage(file(r), p);\n     for (i = 0; i < nTuples(buf); i++) {\n         t = getTuple(buf,i);\n         if (matches(t,C))\n             add t to result set\n     }\n }\n Costpmr  =  Costspace  =  b\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "heap"
  ]
 },
 {
  "question": "What is n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "What is n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "What does n-d selection via multiple index mean ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "Tell me something about n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "Explain n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "Can you tell me about n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "What do you know about n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "What can you tell me about n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "I want to know aboutn-d selection via multiple index",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "Do you have information about n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "Do you know n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "what about n-d selection via multiple index ?",
  "answer": "DBMSs already support building multiple indexes on a table.\n Which indexes to build depends on which queries are asked.\n create table R (a int, b int, c int);\n create index Rax on R (a);\n create index Rbx on R (b);\n create index Rcx on R (c);\n create index Rabx on R (a,b);\n create index Racx on R (a,c);\n create index Rbcx on R (b,c);\n create index Rallx on R (a,b,c);\n But more indexes \u21d2 space + update overheads.\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "selection",
   "via",
   "multiple",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What does n-d query and index mean ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Tell me something about n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Explain n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Can you tell me about n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What do you know about n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What can you tell me about n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "I want to know aboutn-d query and index",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you have information about n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you know n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "what about n-d query and index ?",
  "answer": "Generalised view of pmr and space queries:\n select * from R\n where  a1 op1 C1 and ... and an opn Cn pmr : all opi are equality tests.     space : some opi are range tests.\n Possible approaches to handling such queries ...\n 1. use index on one ai to reduce tuple tests\n 2. use indexes on all ai, and intersect answer sets\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What does n-d query and index mean ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Tell me something about n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Explain n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Can you tell me about n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What do you know about n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What can you tell me about n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "I want to know aboutn-d query and index",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you have information about n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you know n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "what about n-d query and index ?",
  "answer": "If using just one of several indexes, which one to use?\n select * from R\n where  a1 op1 C1 and ... and an opn Cn The one with best selectivity for ai opi Ci   (i.e. fewest matches)\n Factors determining selectivity of ai opi Ci\n assume uniform distribution of values in dom(ai)\n equality test on primary key gives at most one match\n equality test on larger dom(ai) \u21d2 less matches\n range test over large part of dom(ai) \u21d2 many matches\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What does n-d query and index mean ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Tell me something about n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Explain n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Can you tell me about n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What do you know about n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What can you tell me about n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "I want to know aboutn-d query and index",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you have information about n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you know n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "what about n-d query and index ?",
  "answer": "Implementing selection using one of several indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // choose ai with best selectivity\n TupleIDs = IndexLookup(R,ai,opi,Ci)\n // gives { tid1, tid2, ...} for tuples satisfying aiopiCi\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bqix page numbers\n ...\n Cost = Costindex + bqix    (some pages do not contain answers, bqix > bq)\n DBMSs typically maintain statistics to assist with determining selectivity\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What does n-d query and index mean ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Tell me something about n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Explain n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Can you tell me about n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What do you know about n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What can you tell me about n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "I want to know aboutn-d query and index",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you have information about n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "Do you know n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "what about n-d query and index ?",
  "answer": "Implementing selection using multiple indices:\n // Query: select * from R where a1op1C1 and ... and anopnCn\n // assumes an index on at least ai\n TupleIDs = IndexLookup(R,a1,op1,C1)\n foreach attribute ai with an index {\n    tids = IndexLookup(R,ai,opi,Ci)\n    TupleIDs = TupleIDs \u2229 tids\n }\n PageIDs = { }\n foreach tid in TupleIDs\n    { PageIDs = PageIDs \u222a {pageOf(tid)} }\n // PageIDs = a set of bq page numbers\n ...\n Cost = k.Costindex + bq     (assuming indexes on k of n attrs)\n",
  "intent": "description",
  "key_words": [
   "n-d",
   "query",
   "and",
   "index"
  ]
 },
 {
  "question": "What is bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What is bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What does bitmap index mean ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Tell me something about bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Explain bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Can you tell me about bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What do you know about bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What can you tell me about bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "I want to know aboutbitmap index",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Do you have information about bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Do you know bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "what about bitmap index ?",
  "answer": "Alternative index structure, focussing on sets of tuples:\n Index contains bit-strings of r bits, one for each value/range\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What is bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What is bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What does bitmap index mean ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Tell me something about bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Explain bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Can you tell me about bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What do you know about bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What can you tell me about bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "I want to know aboutbitmap index",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Do you have information about bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Do you know bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "what about bitmap index ?",
  "answer": "Answering queries using bitmap index:\n Matches = AllOnes(r)\n foreach attribute A with index {\n    // select ith bit-string for attribute A\n    // based on value associated with A in WHERE\n    Matches = Matches & Bitmaps[A][i]\n }\n // Matches contains 1-bit for each matching tuple\n foreach i in 0..r {\n    if (Matches[i] == 0) continue;\n    t = fetchTuple(i)\n    Results = Results \u222a {t}\n }\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What is bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What is bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What does bitmap index mean ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Tell me something about bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Explain bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Can you tell me about bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What do you know about bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What can you tell me about bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "I want to know aboutbitmap index",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Do you have information about bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "Do you know bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "what about bitmap index ?",
  "answer": "Storage costs for bitmap indexes:\n one bitmap for each value/range for each indexed attribute\n each bitmap has length ceil(r/8) bytes\n e.g. with 50K records and 8KB pages, bitmap fits in one page\n Query execution costs for bitmap indexes:\n read one bitmap for each indexed attribute in query\n perform bitwise AND on bitmaps (in memory)\n read pages containing matching tuples\n Note: bitmaps could index pages (shorter bitmaps, more comparisons)\n",
  "intent": "description",
  "key_words": [
   "bitmap",
   "index"
  ]
 },
 {
  "question": "What is hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What is hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What does hashing and pmr mean ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Tell me something about hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Explain hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Can you tell me about hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What do you know about hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What can you tell me about hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "I want to know abouthashing and pmr",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Do you have information about hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Do you know hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "what about hashing and pmr ?",
  "answer": "For a pmr query like\n select * from R where a1 = C1 and ... and an = Cn\n if one ai is the hash key, query is very efficient\n if no ai is the hash key, need to use linear scan\n Can be alleviated using multi-attribute hashing (mah)\n form a composite hash value involving all attributes\n at query time, some components of composite hash are known (allows us to limit the number of data pages which need to be checked)\n MA.hashing works in conjunction with any dynamic hash scheme.\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What is hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What is hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What does hashing and pmr mean ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Tell me something about hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Explain hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Can you tell me about hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What do you know about hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What can you tell me about hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "I want to know abouthashing and pmr",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Do you have information about hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "Do you know hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "what about hashing and pmr ?",
  "answer": "Multi-attribute hashing parameters:\n file size = b = 2d pages   \u21d2   use d-bit hash values\n relation has n attributes:   a1, a2, ...an\n attribute ai has hash function hi\n attribute ai contributes di bits (to the combined hash value)\n total bits d = \u2211i=1n di\n a choice vector (cv) specifies for all k ... bit j from hi(ai) contributes bit k in combined hash value\n",
  "intent": "description",
  "key_words": [
   "hashing",
   "and",
   "pmr"
  ]
 },
 {
  "question": "What is ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What does ma.hashing example mean ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Tell me something about ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Explain ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What do you know about ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "I want to know aboutma.hashing example",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Do you have information about ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Do you know ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "what about ma.hashing example ?",
  "answer": "Consider relation Deposit(branch,acctNo,name,amount)\n Assume a small data file with 8 main data pages (plus overflows).\n Hash parameters:    d=3     d1=1    d2=1    d3=1    d4=0\n Note that we ignore the amount attribute (d4=0)\n Assumes that nobody will want to ask queries like\n select * from Deposit where amount=533\n Choice vector is designed taking expected queries into account.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What does ma.hashing example mean ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Tell me something about ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Explain ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What do you know about ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "I want to know aboutma.hashing example",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Do you have information about ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Do you know ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "what about ma.hashing example ?",
  "answer": "Choice vector:\n This choice vector tells us:\n bit 0 in hash comes from bit 0 of hash1(a1)   ( b1,0 )\n bit 1 in hash comes from bit 0 of hash2(a2)   ( b2,0 )\n bit 2 in hash comes from bit 0 of hash3(a3)   ( b3,0 )\n bit 3 in hash comes from bit 1 of hash1(a1)   ( b1,1 )\n etc. etc. etc.   (up to as many bits of hashing as required, e.g. 32)\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What does ma.hashing example mean ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Tell me something about ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Explain ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What do you know about ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "I want to know aboutma.hashing example",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Do you have information about ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "Do you know ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "what about ma.hashing example ?",
  "answer": "Consider the tuple:\n branch acctNo name amount\n Downtown 101 Johnston 512\n Hash value (page address) is computed by:\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What is ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What does ma.hashing hash function mean ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Tell me something about ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Explain ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What do you know about ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "I want to know aboutma.hashing hash function",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Do you have information about ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Do you know ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "what about ma.hashing hash function ?",
  "answer": "Auxiliary definitions:\n #define MaxHashSize 32\n typedef unsigned int HashVal;\n // extracts i'th bit from hash value\n #define bit(i,h) (((h) & (1 << (i))) >> (i))\n // choice vector elems\n typedef struct { int attr, int bit } CVelem;\n typedef CVelem ChoiceVec[MaxHashSize];\n // hash function for individual attributes\n HashVal hash1(Tuple t, int i) { ... }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What is ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What is ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What does ma.hashing hash function mean ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Tell me something about ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Explain ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What do you know about ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "I want to know aboutma.hashing hash function",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Do you have information about ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "Do you know ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "what about ma.hashing hash function ?",
  "answer": "Produce combined d-bit hash value for tuple t:\n HashVal hash(Tuple t, ChoiceVec cv, int d)\n {\n     HashVal h[nAttr(t)+1];  // hash for each attr\n     HashVal res = 0, oneBit;\n     int     i, a, b;\n     for (i = 1; i <= nAttr(t); i++)\n         h[i] = hash1(t,i);\n     for (i = 0; i < d; i++) {\n         a = cv[i].attr;\n         b = cv[i].bit;\n         oneBit = bit(b, h[a]);\n         res = res | (oneBit << i);\n     }\n     return res;\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "hash",
   "function"
  ]
 },
 {
  "question": "What is exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "What is exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "What does exercise 5 multi-attribute hashing mean ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "Tell me something about exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "Explain exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "Can you tell me about exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "What do you know about exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "What can you tell me about exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "I want to know aboutexercise 5 multi-attribute hashing",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "Do you have information about exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "Do you know exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "what about exercise 5 multi-attribute hashing ?",
  "answer": "Compute the hash value for the tuple\n ('John Smith','BSc(CompSci)',1990,99.5)\n where d=6,   d1=3,   d2=2,   d3=1, and\n cv = <(1,0), (1,1), (2,0), (3,0), (1,2), (2,1), (3,1), (1,3), ...>\n hash1('John Smith') = ...0101010110110100\n hash2('BSc(CompSci)') = ...1011111101101111\n hash3(1990) = ...0001001011000000\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "multi-attribute",
   "hashing"
  ]
 },
 {
  "question": "What is query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What does query with ma.hashing mean ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Tell me something about query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Explain query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Can you tell me about query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What do you know about query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What can you tell me about query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "I want to know aboutquery with ma.hashing",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you have information about query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you know query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "what about query with ma.hashing ?",
  "answer": "In a partial match query:\n values of some attributes are known\n values of other attributes are unknown\n E.g.\n select amount\n from   Deposit\n where  branch = 'Brighton' and name = 'Green'\n for which we use the shorthand   (Brighton, ?, Green, ?)\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What does query with ma.hashing mean ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Tell me something about query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Explain query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Can you tell me about query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What do you know about query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What can you tell me about query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "I want to know aboutquery with ma.hashing",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you have information about query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you know query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "what about query with ma.hashing ?",
  "answer": "In composite hash for query, values for some bits are unknown:\n What this tells us: any matching tuples must be in pages 101, 111\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What does query with ma.hashing mean ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Tell me something about query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Explain query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Can you tell me about query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What do you know about query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What can you tell me about query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "I want to know aboutquery with ma.hashing",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you have information about query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you know query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "what about query with ma.hashing ?",
  "answer": "Consider the query:\n select amount from Deposit where name = 'Green'\n Need to check pages: 100, 101, 110, 111.\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "ma.hashing"
  ]
 },
 {
  "question": "What is ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What is ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What does ma.hashing query algorithm mean ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Tell me something about ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Explain ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What do you know about ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "I want to know aboutma.hashing query algorithm",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Do you have information about ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Do you know ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "what about ma.hashing query algorithm ?",
  "answer": "// Builds the partial hash value (e.g. 10*0*1)\n // Treats query like tuple with some attr values missing\n nstars = 0;\n for each attribute i in query Q {\n     if (hasValue(Q,i)) {\n         set d[i] bits in composite hash\n             using choice vector and hash(Q,i)\n     } else {\n         set d[i] *'s in composite hash\n             using choice vector\n         nstars++;\n     }\n }\n ...\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What is ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What is ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What does ma.hashing query algorithm mean ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Tell me something about ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Explain ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What do you know about ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "I want to know aboutma.hashing query algorithm",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Do you have information about ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "Do you know ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "what about ma.hashing query algorithm ?",
  "answer": "...\n // Use the partial hash to find candidate pages\n r = openRelation(\"R\",READ);\n for (i = 0; i < 2**nstars; i++) {\n     P = composite hash\n     replace *'s in P\n         using i and choice vector\n     Buf = readPage(file(r), P);\n     for each tuple T in Buf {\n         if (T satisfies pmr query)\n             add T to results\n     }\n }\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "query",
   "algorithm"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What does query cost for ma.hashing mean ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Tell me something about query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Explain query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Can you tell me about query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What do you know about query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What can you tell me about query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "I want to know aboutquery cost for ma.hashing",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you have information about query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you know query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "what about query cost for ma.hashing ?",
  "answer": "Multi-attribute hashing handles a range of query types, e.g.\n select * from R where a=1\n select * from R where d=2\n select * from R where b=3 and c=4\n select * from R where a=5 and b=6 and c=7\n A relation with n attributes has 2n different query types.\n Different query types have different costs   (different no. of *'s)\n Query distribution gives probability pQ of asking each query type Q.\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What does query cost for ma.hashing mean ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Tell me something about query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Explain query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Can you tell me about query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What do you know about query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What can you tell me about query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "I want to know aboutquery cost for ma.hashing",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you have information about query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you know query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "what about query cost for ma.hashing ?",
  "answer": "For a relation  R(a,b,c,d)  ...\n select * from R where a=1\n -- has 1 specified attribute (a)\n -- has 3 unspecified attributes (b,c,d)\n select * from R where b=5 and d=2\n -- has 2 specified attributes (b,d)\n -- has 2 unspecified attributes (a,c)\n select * from R\n where a=1 and b=5 and c=3 and d=2\n -- has 4 specified attributes (a,b,c,d)\n -- has 0 unspecified attributes\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What does query cost for ma.hashing mean ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Tell me something about query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Explain query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Can you tell me about query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What do you know about query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What can you tell me about query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "I want to know aboutquery cost for ma.hashing",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you have information about query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you know query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "what about query cost for ma.hashing ?",
  "answer": "Consider a query of type Q with m attributes unspecified.\n Each unspecified Ai contributes di *'s.\n Total number of *'s is   s  =  \u2211i \u2209 Q di.\n \u21d2 Number of pages to read is   2s  =  \u220fi \u2209 Q 2di.\n Ignoring overflows, Cost(Q) = 2s    (where s is determined by Q)\n Including overflows, Cost(Q) = 2s(1+Ov)\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What does query cost for ma.hashing mean ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Tell me something about query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Explain query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Can you tell me about query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What do you know about query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What can you tell me about query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "I want to know aboutquery cost for ma.hashing",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you have information about query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "Do you know query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "what about query cost for ma.hashing ?",
  "answer": "Min query cost occurs when all attributes are used in query\n Min Costpmr  =  1\n Max query cost occurs when no attributes are specified\n Max Costpmr  =  2d  =  b\n Average cost is given by weighted sum over all query types:\n Avg Costpmr  =  \u2211Q pQ \u220fi \u2209 Q 2di\n Aim to minimise the weighted average query cost over possible query types\n",
  "intent": "description",
  "key_words": [
   "query",
   "cost",
   "for",
   "ma.hashing"
  ]
 },
 {
  "question": "What is optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "What is optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "What does optimising ma.hashing cost mean ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "Tell me something about optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "Explain optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "Can you tell me about optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "What do you know about optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "What can you tell me about optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "I want to know aboutoptimising ma.hashing cost",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "Do you have information about optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "Do you know optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "what about optimising ma.hashing cost ?",
  "answer": "For a given application, useful to minimise Costpmr.\n Can be achieved by choosing appropriate values for di   (cv)\n Heuristics:\n distribution of query types (more bits to frequently used attributes)\n size of attribute domain (\u2264 #bits to represent all values in domain)\n discriminatory power (more bits to highly discriminating attributes)\n Trade-off: making query type Qj more efficient makes Qk less efficient.\n This is a combinatorial optimisation problem, and can be handled by standard optimisation techniques e.g. simulated\n annealing.\n",
  "intent": "description",
  "key_words": [
   "optimising",
   "ma.hashing",
   "cost"
  ]
 },
 {
  "question": "What is ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What does ma.hashing cost example mean ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Tell me something about ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Explain ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What do you know about ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "I want to know aboutma.hashing cost example",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you have information about ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you know ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "what about ma.hashing cost example ?",
  "answer": "Consider a table with four attributes:\n (branch, account, name, amount)   (abbreviated to (br,ac,nm,amt) )\n Possible query types, and likelhood of each:\n Query type Cost pQ\n (?, ?, ?, ?) 8 0\n (br, ?, ?, ?) 4 0.25\n (?, ac, ?, ?) 4 0\n (br, ac, ?, ?) 2 0\n (?, ?, nm, ?) 4 0\n (br, ?, nm, ?) 2 0\n (?, ac, nm, ?) 2 0.25\n (br, ac, nm, ?) 1 0\n (?, ?, ?, amt) 8 0\n (br, ?, ?, amt) 4 0\n (?, ac, ?, amt) 4 0\n (br, ac, ?, amt) 2 0\n (?, ?, nm, amt) 4 0\n (br, ?, nm, amt) 2 0.5\n (?, ac, nm, amt) 2 0\n (br, ac, nm, amt) 1 0\n Cost values are based on choice vector   (dbr = dac = dnm = 1) pQ values can be determined by observation of DB use.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What does ma.hashing cost example mean ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Tell me something about ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Explain ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What do you know about ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "I want to know aboutma.hashing cost example",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you have information about ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you know ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "what about ma.hashing cost example ?",
  "answer": "Consider r=106, Nr=100, b=104, d=14.\n Attribute br occurs in 0.5+0.25 used query types \u21d2 allocate many bits to it e.g. d1=6.\n Attribute nm occurs in 0.5+0.25 of queries \u21d2 allocate many bits to it e.g. d3=4.\n Attribute amt occurs in 0.5 of queries \u21d2 allocate less bits to it e.g. d4=2.\n Attribute ac occurs in 0.25 of queries \u21d2 allocate least bits to it e.g. d2=2.\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What does ma.hashing cost example mean ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Tell me something about ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Explain ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Can you tell me about ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What do you know about ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What can you tell me about ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "I want to know aboutma.hashing cost example",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you have information about ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you know ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "what about ma.hashing cost example ?",
  "answer": "With bits distributed as: d1=6, d2=2, d3=4, d4=2\n Query type Cost pQ\n (br, ?, ?, ?) 28 = 256 0.25\n (?, ac, nm, ?) 28 = 256 0.25\n (br, ?, nm, amt) 22 = 4 0.5\n Cost  =  0.5 \u00d7 22 + 0.25 \u00d7 28 + 0.25 \u00d7 28  =  130\n",
  "intent": "description",
  "key_words": [
   "ma.hashing",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What is multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What does multi-dimensional tree index mean ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Tell me something about multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Explain multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Can you tell me about multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What do you know about multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What can you tell me about multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "I want to know aboutmulti-dimensional tree index",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Do you have information about multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Do you know multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "what about multi-dimensional tree index ?",
  "answer": "Over the last 20 years, from a range of problem areas\n different multi-d tree index schemes have been proposed\n varying primarily in how they partition tuple-space\n Consider three popular schemes:   kd-trees, Quad-trees, R-trees.\n Example data for multi-d trees is based on the following relation:\n create table Rel (\n     X char(1) check (X between 'a' and 'z'),\n     Y integer check (Y between 0 and 9)\n );\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What is multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What is multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What does multi-dimensional tree index mean ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Tell me something about multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Explain multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Can you tell me about multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What do you know about multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What can you tell me about multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "I want to know aboutmulti-dimensional tree index",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Do you have information about multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "Do you know multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "what about multi-dimensional tree index ?",
  "answer": "Example tuples:\n Rel('a',1)  Rel('a',5)  Rel('b',2)  Rel('d',1)\n Rel('d',2)  Rel('d',4)  Rel('d',8)  Rel('g',3)\n Rel('j',7)  Rel('m',1)  Rel('r',5)  Rel('z',9)\n The tuple-space for the above tuples:\n",
  "intent": "description",
  "key_words": [
   "multi-dimensional",
   "tree",
   "index"
  ]
 },
 {
  "question": "What is kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What is kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What does kd-trees mean ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Tell me something about kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Explain kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Can you tell me about kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What do you know about kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What can you tell me about kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "I want to know aboutkd-trees",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Do you have information about kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Do you know kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "what about kd-trees ?",
  "answer": "kd-trees are multi-way search trees where\n each level of the tree partitions on a different attribute\n each node contains n-1 key values, pointers to n subtrees\n",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What is kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What is kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What does kd-trees mean ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Tell me something about kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Explain kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Can you tell me about kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What do you know about kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What can you tell me about kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "I want to know aboutkd-trees",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Do you have information about kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "Do you know kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "what about kd-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "How this tree partitions the tuple space?",
  "intent": "description",
  "key_words": [
   "kd-trees"
  ]
 },
 {
  "question": "What is searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "What is searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "What does searching in kd-trees mean ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "Tell me something about searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "Explain searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "Can you tell me about searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "What do you know about searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "What can you tell me about searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "I want to know aboutsearching in kd-trees",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "Do you have information about searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "Do you know searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "what about searching in kd-trees ?",
  "answer": "// Started by Search(Q, R, 0, kdTreeRoot)\n Search(Query Q, Relation R, Level L, Node N)\n {\n    if (isDataPage(N)) {\n       Buf = getPage(fileOf(R),idOf(N))\n       check Buf for matching tuples\n    } else {\n       a = attrLev[L]\n       if (!hasValue(Q,a))\n          nextNodes = all children of N\n       else {\n          val = getAttr(Q,a)\n          nextNodes = find(N,Q,a,val)\n       }\n       for each C in nextNodes\n          Search(Q, R, L+1, C)\n }  }\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "kd-trees"
  ]
 },
 {
  "question": "What is quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What is quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What does quad tree mean ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Tell me something about quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Explain quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Can you tell me about quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What do you know about quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What can you tell me about quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "I want to know aboutquad tree",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Do you have information about quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Do you know quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "what about quad tree ?",
  "answer": "Quad trees use regular, disjoint partitioning of tuple space.\n for 2d, partition space into quadrants (NW, NE, SW, SE)\n each quadrant can be further subdivided into four, etc.\n Example:\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What is quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What is quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What does quad tree mean ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Tell me something about quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Explain quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Can you tell me about quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What do you know about quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What can you tell me about quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "I want to know aboutquad tree",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Do you have information about quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Do you know quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "what about quad tree ?",
  "answer": "Basis for the partitioning:\n a quadrant that has no sub-partitions is a leaf quadrant\n each leaf quadrant maps to a single data page\n subdivide until points in each quadrant fit into one data page\n ideal: same number of points in each leaf quadrant (balanced)\n point density varies over space \u21d2 different regions require different levels of partitioning\n this means that the tree is not necessarily balanced\n Note: effective for d\u22645, ok for 6\u2264d\u226410, ineffective for d>10\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What is quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What is quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What does quad tree mean ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Tell me something about quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Explain quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Can you tell me about quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What do you know about quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What can you tell me about quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "I want to know aboutquad tree",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Do you have information about quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "Do you know quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "what about quad tree ?",
  "answer": "The previous partitioning gives this tree structure, e.g.\n In this and following examples, we give coords of top-left,bottom-right of a region\n",
  "intent": "description",
  "key_words": [
   "quad",
   "tree"
  ]
 },
 {
  "question": "What is searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "What is searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "What does searching in quad-tree mean ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "Tell me something about searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "Explain searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "Can you tell me about searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "What do you know about searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "What can you tell me about searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "I want to know aboutsearching in quad-tree",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "Do you have information about searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "Do you know searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "what about searching in quad-tree ?",
  "answer": "Space query example:\n Need to traverse: red(NW), green(NW,NE,SW,SE), blue(NE,SE).\n",
  "intent": "description",
  "key_words": [
   "searching",
   "in",
   "quad-tree"
  ]
 },
 {
  "question": "What is r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What is r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What does r-trees mean ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Tell me something about r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Explain r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Can you tell me about r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What do you know about r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What can you tell me about r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "I want to know aboutr-trees",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Do you have information about r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Do you know r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "what about r-trees ?",
  "answer": "R-trees use a flexible, overlapping partitioning of tuple space.\n each node in the tree represents a kd hypercube\n its children represent (possibly overlapping) subregions\n the child regions do not need to cover the entire parent region\n Overlap and partial cover means:\n can optimize space partitioning wrt data distribution\n so that there are similar numbers of points in each region\n Aim: height-balanced, partly-full index pages   (cf. B-tree)\n",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What is r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What is r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What does r-trees mean ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Tell me something about r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Explain r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Can you tell me about r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What do you know about r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What can you tell me about r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "I want to know aboutr-trees",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Do you have information about r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "Do you know r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "what about r-trees ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "r-trees"
  ]
 },
 {
  "question": "What is insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "What is insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "What does insertion into r-tree mean ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "Tell me something about insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "Explain insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "Can you tell me about insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "What do you know about insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "What can you tell me about insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "I want to know aboutinsertion into r-tree",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "Do you have information about insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "Do you know insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "what about insertion into r-tree ?",
  "answer": "Insertion of an object R occurs as follows:\n start at root, look for children that completely contain R\n if no child completely contains R, choose one of the children and expand its boundaries so that it does contain\n R\n if several children contain R, choose one and proceed to child\n repeat above containment search in children of current node\n once we reach data page, insert R if there is room\n if no room in data page, replace by two data pages\n partition existing objects between two data pages\n update node pointing to data pages (may cause B-tree-like propagation of node changes up into tree)\n Note that R may be a point or a polygon.\n",
  "intent": "description",
  "key_words": [
   "insertion",
   "into",
   "r-tree"
  ]
 },
 {
  "question": "What is query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "What is query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "What does query with r-trees mean ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "Tell me something about query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "Explain query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "Can you tell me about query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "What do you know about query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "What can you tell me about query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "I want to know aboutquery with r-trees",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "Do you have information about query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "Do you know query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "what about query with r-trees ?",
  "answer": "Designed to handle space queries and \"where-am-I\" queries.\n \"Where-am-I\" query: find all regions containing a given point P:\n start at root, select all children whose subregions contain P\n if there are zero such regions, search finishes with P not found\n otherwise, recursively search within node for each subregion\n once we reach a leaf, we know that region contains P\n Space (region) queries are handled in a similar way\n we traverse down any path that intersects the query region\n",
  "intent": "description",
  "key_words": [
   "query",
   "with",
   "r-trees"
  ]
 },
 {
  "question": "What is multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does multi-d tree in postgresql mean ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know aboutmulti-d tree in postgresql",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about multi-d tree in postgresql ?",
  "answer": "Up to version 8.2, PostgreSQL had R-tree implementation\n Superseded by GiST = Generalized Search Trees\n GiST indexes parameterise: data type, searching, splitting\n via seven user-defined functions (e.g. picksplit())\n GiST trees have the following structural constraints:\n every node is at least fraction f full (e.g. 0.5)\n the root node has at least two children (unless also a leaf)\n all leaves appear at the same level\n Details: src/backend/access/gist\n",
  "intent": "description",
  "key_words": [
   "multi-d",
   "tree",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "What is cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "What does cost of search in multi-d tree mean ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "Tell me something about cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "Explain cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "Can you tell me about cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "What do you know about cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "What can you tell me about cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "I want to know aboutcost of search in multi-d tree",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "Do you have information about cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "Do you know cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 },
 {
  "question": "what about cost of search in multi-d tree ?",
  "answer": "Difficult to determine cost precisely.\n Best case: pmr query where all attributes have known values\n in kd-trees and quad-trees, follow single tree path\n cost is equal to depth D of tree\n in R-trees, may follow several paths (overlapping partitions)\n Typical case: some attributes are unknown or defined by range\n need to visit multiple sub-trees\n how many depends on: range, choice-points in tree nodes\n Produced: 30 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "cost",
   "of",
   "search",
   "in",
   "multi-d",
   "tree"
  ]
 }
]