[
 {
  "question": "What is week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "What is week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "What does week 3 lecture mean ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "Tell me something about week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "Explain week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "Can you tell me about week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "What do you know about week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "What can you tell me about week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "I want to know aboutweek 3 lecture",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "Do you have information about week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "Do you know week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "what about week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "description",
  "key_words": [
   "week",
   "3",
   "lecture"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you know postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "what about postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you know postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "what about postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you know postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "what about postgresql buffer manager ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What does postgresql buffer manager mean ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Tell me something about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Explain postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Can you tell me about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What do you know about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What can you tell me about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "I want to know aboutpostgresql buffer manager",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you have information about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Do you know postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "what about postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "What is buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "What is buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "What does buffer pool data type mean ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Tell me something about buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Explain buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Can you tell me about buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "What do you know about buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "What can you tell me about buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool data type",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Do you have information about buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Do you know buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "what about buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What does buffer pool function mean ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Tell me something about buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Explain buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Can you tell me about buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What do you know about buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What can you tell me about buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool function",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you have information about buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you know buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "what about buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What does buffer pool function mean ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Tell me something about buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Explain buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Can you tell me about buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What do you know about buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What can you tell me about buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool function",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you have information about buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you know buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "what about buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What does buffer pool function mean ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Tell me something about buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Explain buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Can you tell me about buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What do you know about buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What can you tell me about buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool function",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you have information about buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you know buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "what about buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What does buffer pool function mean ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Tell me something about buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Explain buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Can you tell me about buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What do you know about buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What can you tell me about buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "I want to know aboutbuffer pool function",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you have information about buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Do you know buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "what about buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "description",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "What is clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "What is clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "What does clock-sweep replacement strategy mean ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Tell me something about clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Explain clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Can you tell me about clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "What do you know about clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "What can you tell me about clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "I want to know aboutclock-sweep replacement strategy",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Do you have information about clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Do you know clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "what about clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "description",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "What is exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What does exercise 1 postgresql buffer pool mean ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Tell me something about exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Explain exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Can you tell me about exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What do you know about exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What can you tell me about exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "I want to know aboutexercise 1 postgresql buffer pool",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you have information about exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Do you know exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "what about exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "What is page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "What is page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "What does page tuple management mean ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Tell me something about page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Explain page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Can you tell me about page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "What do you know about page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "What can you tell me about page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "I want to know aboutpage tuple management",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Do you have information about page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Do you know page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "what about page tuple management ?",
  "answer": "",
  "intent": "description",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "What is page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "What is page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "What does page mean ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Tell me something about page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Explain page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Can you tell me about page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "What do you know about page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "What can you tell me about page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "I want to know aboutpage",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Do you have information about page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Do you know page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "what about page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "description",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What is exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What does exercise 2 fixed-length record mean ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Tell me something about exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Explain exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Can you tell me about exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What do you know about exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What can you tell me about exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "I want to know aboutexercise 2 fixed-length record",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Do you have information about exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Do you know exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "what about exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What is exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What is exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What does exercise 3 inserting deleting fixed-length record mean ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Tell me something about exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Explain exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Can you tell me about exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What do you know about exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What can you tell me about exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "I want to know aboutexercise 3 inserting deleting fixed-length record",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Do you have information about exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Do you know exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "what about exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What does page format mean ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Tell me something about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Explain page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Can you tell me about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What do you know about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What can you tell me about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "I want to know aboutpage format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you have information about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Do you know page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "what about page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "description",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "What is exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What is exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What does exercise 4 inserting variable-length record mean ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Tell me something about exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Explain exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Can you tell me about exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What do you know about exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What can you tell me about exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "I want to know aboutexercise 4 inserting variable-length record",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Do you have information about exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Do you know exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "what about exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What is storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "What is storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "What does storage utilisation mean ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Tell me something about storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Explain storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Can you tell me about storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "What do you know about storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "What can you tell me about storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "I want to know aboutstorage utilisation",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Do you have information about storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Do you know storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "what about storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "How many records can fit in a page? (denoted C = capacity)",
  "intent": "description",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "What is exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "What is exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "What does exercise 5 space utilisation mean ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Tell me something about exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Explain exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Can you tell me about exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "What do you know about exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "What can you tell me about exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "I want to know aboutexercise 5 space utilisation",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Do you have information about exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Do you know exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "what about exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "What is overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What is overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What does overflow mean ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Tell me something about overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Explain overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Can you tell me about overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What do you know about overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What can you tell me about overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "I want to know aboutoverflow",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Do you have information about overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Do you know overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "what about overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What is overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What is overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What does overflow mean ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Tell me something about overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Explain overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Can you tell me about overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What do you know about overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What can you tell me about overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "I want to know aboutoverflow",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Do you have information about overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Do you know overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "what about overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What is overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What is overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What does overflow mean ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Tell me something about overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Explain overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Can you tell me about overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What do you know about overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What can you tell me about overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "I want to know aboutoverflow",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Do you have information about overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Do you know overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "what about overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "description",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What does postgresql page representation mean ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Tell me something about postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Explain postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Can you tell me about postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What do you know about postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What can you tell me about postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "I want to know aboutpostgresql page representation",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you have information about postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you know postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "what about postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What does postgresql page representation mean ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Tell me something about postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Explain postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Can you tell me about postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What do you know about postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What can you tell me about postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "I want to know aboutpostgresql page representation",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you have information about postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you know postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "what about postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What does postgresql page representation mean ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Tell me something about postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Explain postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Can you tell me about postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What do you know about postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What can you tell me about postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "I want to know aboutpostgresql page representation",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you have information about postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you know postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "what about postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What does postgresql page representation mean ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Tell me something about postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Explain postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Can you tell me about postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What do you know about postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What can you tell me about postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "I want to know aboutpostgresql page representation",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you have information about postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you know postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "what about postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What does postgresql page representation mean ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Tell me something about postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Explain postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Can you tell me about postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What do you know about postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What can you tell me about postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "I want to know aboutpostgresql page representation",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you have information about postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you know postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "what about postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What does postgresql page representation mean ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Tell me something about postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Explain postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Can you tell me about postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What do you know about postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What can you tell me about postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "I want to know aboutpostgresql page representation",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you have information about postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Do you know postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "what about postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "What is exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "What is exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "What does exercise 6 postgresql page mean ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Tell me something about exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Explain exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Can you tell me about exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "What do you know about exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "What can you tell me about exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "I want to know aboutexercise 6 postgresql page",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Do you have information about exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Do you know exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "what about exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "What is tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "What is tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "What does tuples mean ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Tell me something about tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Explain tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "What do you know about tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "I want to know abouttuples",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Do you have information about tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Do you know tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "what about tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "description",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "What is record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "What is record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "What does record v tuples mean ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Explain record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "What do you know about record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutrecord v tuples",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Do you know record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "what about record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "description",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "What is operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What is operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What does operation on record mean ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Tell me something about operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Explain operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Can you tell me about operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What do you know about operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What can you tell me about operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "I want to know aboutoperation on record",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Do you have information about operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Do you know operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "what about operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What is operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What is operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What does operation on record mean ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Tell me something about operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Explain operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Can you tell me about operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What do you know about operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What can you tell me about operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "I want to know aboutoperation on record",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Do you have information about operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Do you know operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "what about operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "What is operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "What is operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "What does operation on tuples mean ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Explain operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "What do you know about operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutoperation on tuples",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Do you know operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "what about operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "description",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "What is operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What is operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What does operation for access method mean ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Tell me something about operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Explain operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Can you tell me about operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What do you know about operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What can you tell me about operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "I want to know aboutoperation for access method",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Do you have information about operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Do you know operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "what about operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What is operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What is operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What does operation for access method mean ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Tell me something about operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Explain operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Can you tell me about operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What do you know about operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What can you tell me about operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "I want to know aboutoperation for access method",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Do you have information about operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Do you know operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "what about operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "description",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "What is example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "What is example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "What does example query mean ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Tell me something about example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Explain example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Can you tell me about example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "What do you know about example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "What can you tell me about example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "I want to know aboutexample query",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Do you have information about example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Do you know example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "what about example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "description",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "What is fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What is fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What does fixed-length record mean ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Tell me something about fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Explain fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Can you tell me about fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What do you know about fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What can you tell me about fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "I want to know aboutfixed-length record",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Do you have information about fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Do you know fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "what about fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "description",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "What is variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What is variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What does variable-length record mean ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Tell me something about variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Explain variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Can you tell me about variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What do you know about variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What can you tell me about variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "I want to know aboutvariable-length record",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Do you have information about variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Do you know variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "what about variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "description",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What does converting record to tuples mean ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Explain converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What do you know about converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutconverting record to tuples",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you know converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "what about converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What does converting record to tuples mean ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Explain converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What do you know about converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutconverting record to tuples",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you know converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "what about converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What does converting record to tuples mean ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Explain converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What do you know about converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutconverting record to tuples",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you know converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "what about converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What does converting record to tuples mean ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Explain converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What do you know about converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutconverting record to tuples",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Do you know converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "what about converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "description",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What does postgresql tuples mean ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Tell me something about postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Explain postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Can you tell me about postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What do you know about postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What can you tell me about postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "I want to know aboutpostgresql tuples",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you have information about postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Do you know postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "what about postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "description",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "What is dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "What is dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "What does dbms architecture (revisited) mean ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Tell me something about dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Explain dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Can you tell me about dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "What do you know about dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "What can you tell me about dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "I want to know aboutdbms architecture (revisited)",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Do you have information about dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Do you know dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "what about dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "description",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "What is relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What is relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What does relational operation mean ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Tell me something about relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Explain relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Can you tell me about relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What do you know about relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What can you tell me about relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "I want to know aboutrelational operation",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Do you have information about relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Do you know relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "what about relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What is relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What is relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What does relational operation mean ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Tell me something about relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Explain relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Can you tell me about relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What do you know about relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What can you tell me about relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "I want to know aboutrelational operation",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Do you have information about relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Do you know relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "what about relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What is relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What is relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What does relational operation mean ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Tell me something about relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Explain relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Can you tell me about relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What do you know about relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What can you tell me about relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "I want to know aboutrelational operation",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Do you have information about relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Do you know relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "what about relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "description",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What does cost model mean ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Tell me something about cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Explain cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Can you tell me about cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What do you know about cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What can you tell me about cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "I want to know aboutcost model",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you have information about cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you know cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "what about cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What does cost model mean ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Tell me something about cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Explain cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Can you tell me about cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What do you know about cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What can you tell me about cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "I want to know aboutcost model",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you have information about cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you know cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "what about cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What does cost model mean ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Tell me something about cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Explain cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Can you tell me about cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What do you know about cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What can you tell me about cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "I want to know aboutcost model",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you have information about cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you know cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "what about cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What does cost model mean ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Tell me something about cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Explain cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Can you tell me about cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What do you know about cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What can you tell me about cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "I want to know aboutcost model",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you have information about cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Do you know cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "what about cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "description",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "What is query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "What is query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "What does query type mean ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Tell me something about query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Explain query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Can you tell me about query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "What do you know about query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "What can you tell me about query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "I want to know aboutquery type",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Do you have information about query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Do you know query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "what about query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "description",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "What is example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What is example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What does example file structure mean ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Tell me something about example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Explain example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Can you tell me about example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What do you know about example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What can you tell me about example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "I want to know aboutexample file structure",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Do you have information about example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Do you know example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "what about example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What is example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What is example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What does example file structure mean ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Tell me something about example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Explain example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Can you tell me about example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What do you know about example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What can you tell me about example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "I want to know aboutexample file structure",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Do you have information about example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Do you know example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "what about example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "description",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "What is exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "What is exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "What does exercise 7 operation cost mean ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Tell me something about exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Explain exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Can you tell me about exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "What do you know about exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "What can you tell me about exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "I want to know aboutexercise 7 operation cost",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Do you have information about exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Do you know exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "what about exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "What is operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What does operation cost example mean ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Tell me something about operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Explain operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Can you tell me about operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What do you know about operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What can you tell me about operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "I want to know aboutoperation cost example",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you have information about operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you know operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "what about operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What does operation cost example mean ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Tell me something about operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Explain operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Can you tell me about operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What do you know about operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What can you tell me about operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "I want to know aboutoperation cost example",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you have information about operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you know operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "what about operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What does operation cost example mean ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Tell me something about operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Explain operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Can you tell me about operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What do you know about operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What can you tell me about operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "I want to know aboutoperation cost example",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you have information about operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Do you know operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "what about operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "description",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "What is scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What is scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What does scanning mean ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Tell me something about scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Explain scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Can you tell me about scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What do you know about scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What can you tell me about scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "I want to know aboutscanning",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Do you have information about scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Do you know scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "what about scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What is scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What is scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What does scanning mean ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Tell me something about scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Explain scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Can you tell me about scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What do you know about scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What can you tell me about scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "I want to know aboutscanning",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Do you have information about scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Do you know scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "what about scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What is scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What is scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What does scanning mean ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Tell me something about scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Explain scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Can you tell me about scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What do you know about scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What can you tell me about scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "I want to know aboutscanning",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Do you have information about scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Do you know scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "what about scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "description",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "What is selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What is selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What does selection via scanning mean ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Tell me something about selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Explain selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Can you tell me about selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What do you know about selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What can you tell me about selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "I want to know aboutselection via scanning",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Do you have information about selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Do you know selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "what about selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What is selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What is selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What does selection via scanning mean ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Tell me something about selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Explain selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Can you tell me about selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What do you know about selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What can you tell me about selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "I want to know aboutselection via scanning",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Do you have information about selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Do you know selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "what about selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "description",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "What is exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "What is exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "What does exercise 8 cost of search in hashed file mean ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Tell me something about exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Explain exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Can you tell me about exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "What do you know about exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "What can you tell me about exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "I want to know aboutexercise 8 cost of search in hashed file",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Do you have information about exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Do you know exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "what about exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "What is relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What is relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What does relation copying mean ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Tell me something about relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Explain relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Can you tell me about relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What do you know about relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What can you tell me about relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "I want to know aboutrelation copying",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Do you have information about relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Do you know relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "what about relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What is relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What is relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What does relation copying mean ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Tell me something about relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Explain relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Can you tell me about relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What do you know about relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What can you tell me about relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "I want to know aboutrelation copying",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Do you have information about relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Do you know relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "what about relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "description",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "What is exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "What is exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "What does exercise 9 cost of relation copy mean ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Tell me something about exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Explain exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Can you tell me about exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "What do you know about exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "What can you tell me about exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "I want to know aboutexercise 9 cost of relation copy",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Do you have information about exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Do you know exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "what about exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "What is exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "What is exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "What does exercise 10 postgresql tuple visibility mean ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Tell me something about exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Explain exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Can you tell me about exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "What do you know about exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "What can you tell me about exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "I want to know aboutexercise 10 postgresql tuple visibility",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Do you have information about exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Do you know exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "what about exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "description",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "What is scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does scanning in postgresql mean ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know aboutscanning in postgresql",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What does scanning in postgresql mean ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Tell me something about scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Explain scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Can you tell me about scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What do you know about scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What can you tell me about scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "I want to know aboutscanning in postgresql",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you have information about scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Do you know scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "what about scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "What is scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "What is scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "What does scanning in other file structure mean ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Tell me something about scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Explain scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Can you tell me about scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "What do you know about scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "What can you tell me about scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "I want to know aboutscanning in other file structure",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Do you have information about scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Do you know scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "what about scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "description",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 }
]