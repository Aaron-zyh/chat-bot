[
 {
  "question": "How to solve week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "How to resolve week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "How to mitigate week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "Solution for week 3 lecture",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "Provide me some Solution for week 3 lecture",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "mitigation for week 3 lecture",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "How to stop week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "How to defend week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "How to get secured against week 3 lecture ?",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "Solution, week 3 lecture",
  "answer": "About PostgreSQL Buffer Manager\n",
  "intent": "solution",
  "key_words": [
   "lecture",
   "week 3"
  ]
 },
 {
  "question": "How to solve postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to resolve postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to mitigate postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution for postgresql buffer manager",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql buffer manager",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "mitigation for postgresql buffer manager",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to stop postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to defend postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to get secured against postgresql buffer manager ?",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution, postgresql buffer manager",
  "answer": "PostgreSQL buffer manager:\n provides a shared pool of memory buffers for all backends\n all access methods get data from disk via buffer manager\n Buffers are located in a large region of shared memory.\n Definitions: \u00a0src/include/storage/buf*.h\n Functions: \u00a0src/backend/storage/buffer/*.c\n  Buffer code is also used by backends who want a private buffer pool\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to solve postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to resolve postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to mitigate postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution for postgresql buffer manager",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql buffer manager",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "mitigation for postgresql buffer manager",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to stop postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to defend postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to get secured against postgresql buffer manager ?",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution, postgresql buffer manager",
  "answer": "Buffer pool consists of:\n BufferDescriptors\n shared fixed array (size NBuffers) of BufferDesc\n BufferBlocks\n shared fixed array (size NBuffers) of Buffer\n Buffer = index values in above arrays\n indexes: global buffers 1..NBuffers; local buffers negative\n Size of buffer pool is set in postgresql.conf, e.g.\n shared_buffers = 16MB   # min 128KB, 16*8KB buffers",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to solve postgresql buffer manager ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to resolve postgresql buffer manager ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to mitigate postgresql buffer manager ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution for postgresql buffer manager",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql buffer manager",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "mitigation for postgresql buffer manager",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to stop postgresql buffer manager ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to defend postgresql buffer manager ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to get secured against postgresql buffer manager ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution, postgresql buffer manager",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to solve postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to resolve postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to mitigate postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution for postgresql buffer manager",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql buffer manager",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "mitigation for postgresql buffer manager",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to stop postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to defend postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to get secured against postgresql buffer manager ?",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "Solution, postgresql buffer manager",
  "answer": "include/storage/buf.h\n basic buffer manager data types (e.g. Buffer)\n include/storage/bufmgr.h\n definitions for buffer manager function interface  (i.e. functions that other parts of the system call to use buffer manager)\n include/storage/buf_internals.h\n definitions for buffer manager internals (e.g. BufferDesc)\n Code: backend/storage/buffer/*.c\n Commentary: backend/storage/buffer/README\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "buffer",
   "manager"
  ]
 },
 {
  "question": "How to solve buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "How to resolve buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "How to mitigate buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Solution for buffer pool data type",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Provide me some Solution for buffer pool data type",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "mitigation for buffer pool data type",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "How to stop buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "How to defend buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "How to get secured against buffer pool data type ?",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "Solution, buffer pool data type",
  "answer": "typedef struct buftag {    RelFileNode rnode;     /* physical relation identifier */    ForkNumber  forkNum;    BlockNumber blockNum;  /* relative to start of reln */ } BufferTag;  BufFlags: BM_DIRTY, BM_VALID, BM_TAG_VALID, BM_IO_IN_PROGRESS, ... typedef struct sbufdesc { (simplified)    BufferTag tag;         /* ID of page contained in buffer */    BufFlags  flags;       /* see bit definitions above */    uint16    usage_count; /* usage counter for clock sweep */    unsigned  refcount;    /* # of backends holding pins */    int       buf_id;      /* buffer's index number (from 0) */    int       freeNext;    /* link in freelist chain */    ... } BufferDesc;",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "data",
   "type"
  ]
 },
 {
  "question": "How to solve buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to resolve buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to mitigate buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution for buffer pool function",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Provide me some Solution for buffer pool function",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "mitigation for buffer pool function",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to stop buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to defend buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to get secured against buffer pool function ?",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution, buffer pool function",
  "answer": "Buffer manager interface:\n Buffer ReadBuffer(Relation r, BlockNumber n)\n ensures nth page of file for relation r is loaded  (may need to remove an existing unpinned page and read data from file)\n increments reference (pin) count and usage count for buffer\n returns index of loaded page in buffer pool (Buffer value)\n assumes main fork, so no ForkNumber required\n Actually a special case of ReadBuffer_Common, which also handles variations like different replacement strategy, forks, temp buffers, ...\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to solve buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to resolve buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to mitigate buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution for buffer pool function",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Provide me some Solution for buffer pool function",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "mitigation for buffer pool function",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to stop buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to defend buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to get secured against buffer pool function ?",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution, buffer pool function",
  "answer": "Buffer manager interface (cont):\n void ReleaseBuffer(Buffer buf)\n decrement pin count on buffer\n if pin count falls to zero,  ensures all activity on buffer is completed before returning\n void MarkBufferDirty(Buffer buf)\n marks a buffer as modified\n requires that buffer is pinned and locked\n actual write is done later (e.g. when buffer replaced)\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to solve buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to resolve buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to mitigate buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution for buffer pool function",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Provide me some Solution for buffer pool function",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "mitigation for buffer pool function",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to stop buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to defend buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to get secured against buffer pool function ?",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution, buffer pool function",
  "answer": "Additional buffer manager functions:\n Page BufferGetPage(Buffer buf)\n finds actual data associated with buffer in pool\n returns reference to memory where data is located\n BufferIsPinned(Buffer buf)\n check whether this backend holds a pin on buffer\n CheckPointBuffers\n write data in checkpoint logs (for recovery)\n flush all dirty blocks in buffer pool to disk\n etc. etc. etc.\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to solve buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to resolve buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to mitigate buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution for buffer pool function",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Provide me some Solution for buffer pool function",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "mitigation for buffer pool function",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to stop buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to defend buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to get secured against buffer pool function ?",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "Solution, buffer pool function",
  "answer": "Important internal buffer manager function:\n BufferDesc *BufferAlloc(  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 Relation r, ForkNumber f,  \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 BlockNumber n, bool *found)\n used by ReadBuffer to find a buffer for (r,f,n)\n if (r,f,n) already in pool, pin it and return descriptor\n if no available buffers, select buffer to be replaced\n returned descriptor is pinned and marked as holding (r,f,n)\n does not read; ReadBuffer has to do the actual I/O\n",
  "intent": "solution",
  "key_words": [
   "buffer",
   "pool",
   "function"
  ]
 },
 {
  "question": "How to solve clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "How to resolve clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "How to mitigate clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Solution for clock-sweep replacement strategy",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Provide me some Solution for clock-sweep replacement strategy",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "mitigation for clock-sweep replacement strategy",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "How to stop clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "How to defend clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "How to get secured against clock-sweep replacement strategy ?",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "Solution, clock-sweep replacement strategy",
  "answer": "PostgreSQL page replacement strategy: clock-sweep\n treat buffer pool as circular list of buffer slots\n NextVictimBuffer holds index of next possible evictee\n if page is pinned or \"popular\", leave it\n usage_count implements \"popularity/recency\" measure\n incremented on each access to buffer (up to small limit)\n decremented each time considered for eviction\n increment NextVictimBuffer and try again (wrap at end)\n For specialised kinds of access (e.g. sequential scan), can allocate a private \"buffer ring\" with different replacement strategy.\n",
  "intent": "solution",
  "key_words": [
   "clock-sweep",
   "replacement",
   "strategy"
  ]
 },
 {
  "question": "How to solve exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How to resolve exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How to mitigate exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Solution for exercise 1 postgresql buffer pool",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 1 postgresql buffer pool",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "mitigation for exercise 1 postgresql buffer pool",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How to stop exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How to defend exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How to get secured against exercise 1 postgresql buffer pool ?",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "Solution, exercise 1 postgresql buffer pool",
  "answer": "Consider an initally empty buffer pool with only 3 slots.\n Show the state of the pool after each of the following:\n Req R0, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R0, Req R1, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R1, Req R2, Req S0, Rel S0, Req S1, Rel S1, Req S2, Rel S2, Rel R2 Treat BufferDesc entries as\n (tag, usage_count, refcount, freeNext) Assume freeList and nextVictim global variables.\n Pages\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "1",
   "postgresql",
   "buffer",
   "pool"
  ]
 },
 {
  "question": "How to solve page tuple management ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "How to resolve page tuple management ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "How to mitigate page tuple management ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Solution for page tuple management",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Provide me some Solution for page tuple management",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "mitigation for page tuple management",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "How to stop page tuple management ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "How to defend page tuple management ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "How to get secured against page tuple management ?",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "Solution, page tuple management",
  "answer": "",
  "intent": "solution",
  "key_words": [
   "page",
   "tuple",
   "management"
  ]
 },
 {
  "question": "How to solve page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "How to resolve page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "How to mitigate page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Solution for page",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Provide me some Solution for page",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "mitigation for page",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "How to stop page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "How to defend page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "How to get secured against page ?",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "Solution, page",
  "answer": "Database applications view data as:\n a collection of records (tuples)\n records can be accessed via a TupleId (aka RecordId or RID)\n TupleId = (RelId + PageNum + TupIndex)\n The disk and buffer manager provide the following view:\n data is a sequence of fixed-size pages (aka \"blocks\")\n pages can be (random) accessed via a PageId\n each page contains zero or more tuple values\n Page format = how space/tuples are organised within a Page.\n",
  "intent": "solution",
  "key_words": [
   "page"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Ultimately, a Page is simply an array of bytes (byte[]).\n We want to interpret/manipulate it as a collection of Records.\n Typical operations on Pages:\n request_page(pid) ... get page via its PageId\n get_record(rid) ... get record via its TupleId\n rid = insert_record(pid,rec) ... add new record into page\n update_record(rid,rec) ... update value of specified record\n delete_record(rid) ... remove a specified record from a page\n  Note: rid typically contains (PageId,TupIndex), so no explicit pid needed\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Factors affecting Page formats:\n determined by record size flexibility \u00a0 (fixed, variable)\n how free space within Page is managed\n whether some data is stored outside Page\n does Page have an associated overflow chain?\n are large data values stored elsewhere? (e.g. TOAST)\n can one tuple span multiple Pages?\n Implementation of Page operations critically depends on format.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "For fixed-length records, use record slots.\n insert: place new record in first available slot\n delete: two possibilities for handling free record slots:\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to resolve exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to mitigate exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Solution for exercise 2 fixed-length record",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 2 fixed-length record",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "mitigation for exercise 2 fixed-length record",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to stop exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to defend exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to get secured against exercise 2 fixed-length record ?",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Solution, exercise 2 fixed-length record",
  "answer": "Give examples of table definitions\n which result in fixed-length records\n which result in variable-length records\n create table R ( ...); What are the common features of each type of table?\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "2",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to solve exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to resolve exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to mitigate exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Solution for exercise 3 inserting deleting fixed-length record",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 3 inserting deleting fixed-length record",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "mitigation for exercise 3 inserting deleting fixed-length record",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to stop exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to defend exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to get secured against exercise 3 inserting deleting fixed-length record ?",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Solution, exercise 3 inserting deleting fixed-length record",
  "answer": "For each of the following Page formats:\n compacted/packed free space\n unpacked free space (with bitmap)\n Implement\n a suitable data structure to represent a Page\n a function to insert a new record\n a function to delete a record\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "3",
   "inserting",
   "deleting",
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "For variable-length records, must use slot directory.\n Possibilities for handling free-space within block:\n compacted (one region of free space)\n fragmented (distributed free space)\n In practice, a combination is useful:\n normally fragmented (cheap to maintain)\n compacted when needed (e.g. record won't fit)\n  Important aspect of using slot directory\n location of tuple within page can change, tuple index does not change\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Compacted free space: \u00a0\n  Note: \"pointers\" are implemented as word offsets within block.\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Fragmented free space: \u00a0\n ",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Initial page state (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Before inserting record 7 (compacted free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Initial page state (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "Before inserting record 7 (fragmented free space) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to resolve page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to mitigate page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution for page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Provide me some Solution for page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "mitigation for page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to stop page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to defend page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to get secured against page format ?",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "Solution, page format",
  "answer": "After inserting record 7 (80 bytes) ...\n",
  "intent": "solution",
  "key_words": [
   "page",
   "format"
  ]
 },
 {
  "question": "How to solve exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to resolve exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to mitigate exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Solution for exercise 4 inserting variable-length record",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 4 inserting variable-length record",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "mitigation for exercise 4 inserting variable-length record",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to stop exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to defend exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to get secured against exercise 4 inserting variable-length record ?",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Solution, exercise 4 inserting variable-length record",
  "answer": "For both of the following page formats\n 1. variable-length records, with compacted free space\n 2. variable-length records, with fragmented free space\n implement the insert() function.\n Use the above page format, but also assume:\n page size is 1024 bytes\n tuples start on 4-byte boundaries\n references into page are all 8-bits (1 byte) long\n a function recSize(r) gives size in bytes\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "4",
   "inserting",
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to solve storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "How to resolve storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "How to mitigate storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Solution for storage utilisation",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Provide me some Solution for storage utilisation",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "mitigation for storage utilisation",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "How to stop storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "How to defend storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "How to get secured against storage utilisation ?",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "Solution, storage utilisation",
  "answer": " Depends on:\n page size ... typical values: 1KB, 2KB, 4KB, 8KB\n record size ... typical values: 64B, 200B, app-dependent\n page header data ... typically: 4B - 32B\n slot directory ... depends on how many records\n We typically consider average record size (R)\n Given C, \u00a0 HeaderSize + C*SlotSize + C*R \u00a0\u2264\u00a0 PageSize\n",
  "intent": "solution",
  "key_words": [
   "storage",
   "utilisation"
  ]
 },
 {
  "question": "How to solve exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "How to resolve exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "How to mitigate exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Solution for exercise 5 space utilisation",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 5 space utilisation",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "mitigation for exercise 5 space utilisation",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "How to stop exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "How to defend exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "How to get secured against exercise 5 space utilisation ?",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "Solution, exercise 5 space utilisation",
  "answer": "Consider the following page/record information:\n page size = 1KB = 1024 bytes = 210 bytes\n records: (a:int,b:varchar(20),c:char(10),d:int)\n records are all aligned on 4-byte boundaries\n c field padded to ensure d starts on 4-byte boundary\n each records has 4 field-offsets at start of record (each 1 byte)\n char(10) field rounded up to 12-bytes to preserve alignment\n maximum size of b values = 20 bytes; average size = 16 bytes\n page has 32-bytes of header information, starting at byte 0\n only insertions, no deletions or updates\n Calculate C = average number of records per page.\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "5",
   "space",
   "utilisation"
  ]
 },
 {
  "question": "How to solve overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to resolve overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to mitigate overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Solution for overflow",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Provide me some Solution for overflow",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "mitigation for overflow",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to stop overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to defend overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to get secured against overflow ?",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Solution, overflow",
  "answer": "Sometimes, it may not be possible to insert a record into a page:\n 1. no free-space fragment large enough\n 2. overall free-space is not large enough\n 3. the record is larger than the page\n 4. no more free directory slots in page\n For case (1), can first try to compact free-space within the page.\n If still insufficient space, we need an alternative solution ...\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to solve overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to resolve overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to mitigate overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Solution for overflow",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Provide me some Solution for overflow",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "mitigation for overflow",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to stop overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to defend overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to get secured against overflow ?",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Solution, overflow",
  "answer": "File organisation determines how cases (2)..(4) are handled.\n If records may be inserted anywhere that there is free space\n cases (2) and (4) can be handled by making a new page\n case (3) requires either spanned records or \"overflow file\"\n If file organisation determines record placement (e.g. hashed file)\n cases (2) and (4) require an \"overflow page\"\n case (3) requires an \"overflow file\"\n With overflow pages, rid structure may need modifying (rel,page,ovfl,rec)\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to solve overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to resolve overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to mitigate overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Solution for overflow",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Provide me some Solution for overflow",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "mitigation for overflow",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to stop overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to defend overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to get secured against overflow ?",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "Solution, overflow",
  "answer": "Overflow files for very large records and BLOBs:\n Record-based handling of overflows:\n We discuss overflow pages in more detail when covering Hash Files.\n",
  "intent": "solution",
  "key_words": [
   "overflow"
  ]
 },
 {
  "question": "How to solve postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to resolve postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to mitigate postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution for postgresql page representation",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql page representation",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "mitigation for postgresql page representation",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to stop postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to defend postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to get secured against postgresql page representation ?",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution, postgresql page representation",
  "answer": "Functions: src/backend/storage/page/*.c\n Definitions: src/include/storage/bufpage.h\n Each page is 8KB (default BLCKSZ) and contains:\n header (free space pointers, flags, xact data)\n array of (offset,length) pairs for tuples in page\n free space region (between array and tuple data)\n actual tuples themselves (inserted from end towards start)\n (optionally) region for special data (e.g. index data)\n Large data items are stored in separate (TOAST) files \u00a0 (implicit)\n Also supports ~SQL-standard BLOBs \u00a0 (explicit large data items)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to solve postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to resolve postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to mitigate postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution for postgresql page representation",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql page representation",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "mitigation for postgresql page representation",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to stop postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to defend postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to get secured against postgresql page representation ?",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution, postgresql page representation",
  "answer": "PostgreSQL page layout:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to solve postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to resolve postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to mitigate postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution for postgresql page representation",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql page representation",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "mitigation for postgresql page representation",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to stop postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to defend postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to get secured against postgresql page representation ?",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution, postgresql page representation",
  "answer": "Page-related data types:\n  // a Page is simply a pointer to start of buffer typedef Pointer Page;  // indexes into the tuple directory typedef uint16  LocationIndex;  // entries in tuple directory (line pointer array) typedef struct ItemIdData {    unsigned   lp_off:15,    // tuple offset from start of page               lp_flags:2,   // unused,normal,redirect,dead               lp_len:15;    // length of tuple (bytes) } ItemIdData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to solve postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to resolve postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to mitigate postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution for postgresql page representation",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql page representation",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "mitigation for postgresql page representation",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to stop postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to defend postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to get secured against postgresql page representation ?",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution, postgresql page representation",
  "answer": "Page-related data types: (cont)\n  typedef struct PageHeaderData {    XLogRecPtr    pd_lsn;      // xact log record for last change    uint16        pd_tli;      // xact log reference information    uint16        pd_flags;    // flag bits (e.g. free, full, ...    LocationIndex pd_lower;    // offset to start of free space    LocationIndex pd_upper;    // offset to end of free space    LocationIndex pd_special;  // offset to start of special space    uint16        pd_pagesize_version;    TransactionId pd_prune_xid;// is pruning useful in data page?    ItemIdData    pd_linp[1];  // beginning of line pointer array } PageHeaderData;  typedef PageHeaderData *PageHeader;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to solve postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to resolve postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to mitigate postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution for postgresql page representation",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql page representation",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "mitigation for postgresql page representation",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to stop postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to defend postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to get secured against postgresql page representation ?",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution, postgresql page representation",
  "answer": "Operations on Pages:\n void PageInit(Page page, Size pageSize, ...)\n initialize a Page buffer to empty page\n in particular, sets pd_lower and pd_upper\n OffsetNumber PageAddItem(Page page,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Item item, Size size, ...)\n insert one tuple (or index entry) into a Page\n fails if: not enough free space, too many tuples\n void PageRepairFragmentation(Page page)\n compact tuple storage to give one large free space region\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to solve postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to resolve postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to mitigate postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution for postgresql page representation",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql page representation",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "mitigation for postgresql page representation",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to stop postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to defend postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to get secured against postgresql page representation ?",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "Solution, postgresql page representation",
  "answer": "PostgreSQL has two kinds of pages:\n heap pages which contain tuples\n index pages which contain index entries\n Both kinds of page have the same page layout.\n One important difference:\n index entries tend be a smaller than tuples\n can typically fit more index entries per page\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "page",
   "representation"
  ]
 },
 {
  "question": "How to solve exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "How to resolve exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "How to mitigate exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Solution for exercise 6 postgresql page",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 6 postgresql page",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "mitigation for exercise 6 postgresql page",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "How to stop exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "How to defend exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "How to get secured against exercise 6 postgresql page ?",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "Solution, exercise 6 postgresql page",
  "answer": "Draw diagrams of a PostgreSQL heap page\n when it is initially empty\n after three tuples have been inserted  \u00a0\u00a0\u00a0 with lengths of 60, 80, and 70 bytes\n after the 80 byte tuple is deleted (but before vacuuming)\n after a new 50 byte tuple is added\n Show the values in the tuple header.\n Assume that there is no special space in the page.\n Tuples\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "6",
   "postgresql",
   "page"
  ]
 },
 {
  "question": "How to solve tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "How to resolve tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "How to mitigate tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Solution for tuples",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for tuples",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "mitigation for tuples",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "How to stop tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "How to defend tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "How to get secured against tuples ?",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "Solution, tuples",
  "answer": "Each page contains a collection of tuples\n [Diagram:Pics/storage/page-tuples-small.png]\n  What do tuples contain? How are they structured internally?\n",
  "intent": "solution",
  "key_words": [
   "tuples"
  ]
 },
 {
  "question": "How to solve record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "How to resolve record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Solution for record v tuples",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for record v tuples",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "mitigation for record v tuples",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "How to stop record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "How to defend record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against record v tuples ?",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "Solution, record v tuples",
  "answer": "A table is defined by a collection of attributes (schema), e.g.\n create table Employee (    id   integer primary key,    name varchar(20),    job  varchar(10),    dept number(4) ); Tuple = collection of attribute values for such a schema, e.g.\n (33357462, 'Neil Young', 'Musician', 0277) Record = sequence of bytes, containing data for one tuple, e.g.\n [Diagram:Pics/storage/tuple-bytes-small.png]\n Byte-sequence needs to be interpreted relative to schema to get tuple\n",
  "intent": "solution",
  "key_words": [
   "record",
   "v",
   "tuples"
  ]
 },
 {
  "question": "How to solve operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to resolve operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to mitigate operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Solution for operation on record",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Provide me some Solution for operation on record",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "mitigation for operation on record",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to stop operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to defend operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to get secured against operation on record ?",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Solution, operation on record",
  "answer": "Common operation one records ... access record via RecordId:\n Record get_record(RecordId rid) {     Page buf = request_page(relId(rid), pageNum(rid));     return get_record_from_page(buf, recNum(rid)); } where \u00a0RecordId = TupleId = (RelId, PageNum, TupIndex)\n Gives a sequence of bytes, which needs to be interpreted, e.g.\n Relation rel = ... // relation schema Record r = get_record(rid) Tuple t = makeTuple(rel,r) Once we have a tuple, we can access individual attributes/fields\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to solve operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to resolve operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to mitigate operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Solution for operation on record",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Provide me some Solution for operation on record",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "mitigation for operation on record",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to stop operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to defend operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to get secured against operation on record ?",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "Solution, operation on record",
  "answer": "Other operations on records (via their RecordId) ...\n update_record(rid,rec)\n modifies a record \"in place\" \u00a0(replaced by new rec)\n note: PostgreSQL marks old record as \"obsolete\", creates new modified record\n rid = insert_record(pid,rec)\n insert record into specified page, returning RecordId of new record\n delete_record(rid)\n remove record \u00a0(mark as deleted)\n All of the above, first require a page fetch (via buffer pool)\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "record"
  ]
 },
 {
  "question": "How to solve operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "How to resolve operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Solution for operation on tuples",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for operation on tuples",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "mitigation for operation on tuples",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "How to stop operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "How to defend operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against operation on tuples ?",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "Solution, operation on tuples",
  "answer": "Tuple t = makeTuple(rel,rec)\n convert record to tuple data structure \u00a0(may be identity mapping)\n  Typ \u00a0 getTypField(Tuple t, int fno)\n extract the fno'th field from a Tuple as a value of type Typ\n E.g. \u00a0 int x = getIntField(t,1), \u00a0 char *s = getStrField(t,2)\n  void \u00a0setTypField(Tuple t, int fno, Typ val)\n set the value of the fno'th field of a Tuple to val\n E.g. \u00a0 setIntField(t,1,42), \u00a0 setStrField(t,2,\"abc\")\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "on",
   "tuples"
  ]
 },
 {
  "question": "How to solve operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to resolve operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to mitigate operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Solution for operation for access method",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Provide me some Solution for operation for access method",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "mitigation for operation for access method",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to stop operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to defend operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to get secured against operation for access method ?",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Solution, operation for access method",
  "answer": "Tuple get_tuple(RecordId rid)\n fetch the tuple specified by rid; return reference to Tuple\n used for access via an index, where index entries are (key,rid)\n  Tuple get_tuple_from_page(Page p, int rno)\n get the rno'th tuple from an already-buffered page\n called during a scan, once we have loaded relevant page\n used to implement \u00a0 for each tuple t in page p\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to solve operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to resolve operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to mitigate operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Solution for operation for access method",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Provide me some Solution for operation for access method",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "mitigation for operation for access method",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to stop operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to defend operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to get secured against operation for access method ?",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "Solution, operation for access method",
  "answer": "Access methods typically involve iterators, e.g.\n  Scan s = start_scan(Rel r, ...)\n commence a scan of relation r\n Scan may include condition to implement WHERE-clause\n Scan holds data on progress through file (e.g. current page)\n  Tuple next_tuple(Scan s)\n return Tuple immediately following last accessed one\n returns NULL if no more Tuples left in the relation\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "for",
   "access",
   "method"
  ]
 },
 {
  "question": "How to solve example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "How to resolve example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "How to mitigate example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Solution for example query",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Provide me some Solution for example query",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "mitigation for example query",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "How to stop example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "How to defend example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "How to get secured against example query ?",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "Solution, example query",
  "answer": "Example: simple scan of a table ...\n select name from Employee implemented as:\n DB db = openDatabase(\"myDB\"); Rel r = openRel(db,\"Employee\"); Scan s = start_scan(r); Tuple t;  // current tuple while ((t = next_tuple(s)) != NULL) {    char *name = getStrField(t,2);    printf(\"%s\\n\", name); }",
  "intent": "solution",
  "key_words": [
   "example",
   "query"
  ]
 },
 {
  "question": "How to solve fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to resolve fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to mitigate fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Solution for fixed-length record",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Provide me some Solution for fixed-length record",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "mitigation for fixed-length record",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to stop fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to defend fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to get secured against fixed-length record ?",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "Solution, fixed-length record",
  "answer": "Encoding scheme for fixed-length records:\n record format (length + offsets) stored in catalogue\n data values stored in fixed-size slots in data pages\n Since record format is frequently used at query time, should be in memory.\n",
  "intent": "solution",
  "key_words": [
   "fixed-length",
   "record"
  ]
 },
 {
  "question": "How to solve variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to resolve variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to mitigate variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Solution for variable-length record",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Provide me some Solution for variable-length record",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "mitigation for variable-length record",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to stop variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to defend variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to get secured against variable-length record ?",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "Solution, variable-length record",
  "answer": "Some encoding schemes for variable-length records:\n Prefix each field by length\n Terminate fields by delimiter\n Array of offsets\n",
  "intent": "solution",
  "key_words": [
   "variable-length",
   "record"
  ]
 },
 {
  "question": "How to solve converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to resolve converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution for converting record to tuples",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for converting record to tuples",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "mitigation for converting record to tuples",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to stop converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to defend converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against converting record to tuples ?",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution, converting record to tuples",
  "answer": "A Record is an array of bytes (byte[])\n representing the data values from a typed Tuple\n A Tuple is a collection of named,typed values\n analogous to a struct in C\n Information on how to interpret the bytes as typed values\n will be contained in schema data in DBMS catalogue\n may be stored in the header for the data file\n may be stored partly in the record and partly in the schema\n For variable-length records, some formatting info ...\n must be stored in the record or in the page directory\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to solve converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to resolve converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution for converting record to tuples",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for converting record to tuples",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "mitigation for converting record to tuples",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to stop converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to defend converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against converting record to tuples ?",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution, converting record to tuples",
  "answer": "DBMSs typically define a fixed set of field types, e.g.\n DATE, \u00a0FLOAT, \u00a0INTEGER, \u00a0NUMBER(n), \u00a0VARCHAR(n), ...\n This determines implementation-level data types:\n DATE time_t\n FLOAT float,double\n INTEGER int,long\n NUMBER(n) int[] (?)\n VARCHAR(n) char[]\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to solve converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to resolve converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution for converting record to tuples",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for converting record to tuples",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "mitigation for converting record to tuples",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to stop converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to defend converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against converting record to tuples ?",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution, converting record to tuples",
  "answer": "A Tuple can be defined as\n a list of field descriptors for a record instance  (where a FieldDesc gives (offset,length,type) information)\n along with a reference to the Record data\n typedef struct {     ushort    nfields;  // # fields     FieldDesc fields[]; // field descriptions     Record    data; } Tuple; Fields are derived from relation descriptor + record instance data.\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to solve converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to resolve converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution for converting record to tuples",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for converting record to tuples",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "mitigation for converting record to tuples",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to stop converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to defend converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against converting record to tuples ?",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "Solution, converting record to tuples",
  "answer": "The data field could be either\n a pointer to byte-chunk stored elsewhere in memory\n [Diagram:Pics/storage/rec8-small.png]\n data itself appended to struct \u00a0 (used widely in PostgreSQL)\n",
  "intent": "solution",
  "key_words": [
   "converting",
   "record",
   "to",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Definitions: include/postgres.h, \u00a0include/access/*tup*.h\n Functions: backend/access/common/*tup*.c\n e.g. HeapTuple heap_form_tuple(desc, values[], isnull[])\n e.g. heap_deform_tuple(tuple, desc, values[], isnull[])\n PostgreSQL defines tuples via:\n a contiguous chunk of memory\n starting with a header giving e.g. #fields, nulls\n followed by the data values (as sequence of Datum)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Tuple structure:\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Tuple-related data types:\n // representation of a data value typedef uintptr_t Datum; The actual data value:\n may be stored in the Datum (e.g. int)\n may have a header with length (for varlen attributes)\n may be stored in a TOAST file\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n // TupleDesc: schema-related information for HeapTuples  typedef struct tupleDesc  {     int         natts;          // number of attributes in the tuple      Form_pg_attribute *attrs;     // attrs[N] is a pointer to description of attribute N+1      TupleConstr *constr;        // constraints, or NULL if none      Oid         tdtypeid;       // composite type ID for tuple type      int32       tdtypmod;       // typmod for tuple type      bool        tdhasoid;       // does tuple have oid attribute?      int         tdrefcount;     // reference count (-1 if not counting) } *TupleDesc;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef HeapTupleData *HeapTuple;  typedef struct HeapTupleData {     uint32           t_len;  // length of *t_data      ItemPointerData t_self;  // SelfItemPointer      Oid         t_tableOid;  // table the tuple came from      HeapTupleHeader t_data;  // tuple header and data  } HeapTupleData; PostgreSQL allocates a single block of data for tuple\n containing the above struct, followed by data byte[]\n no explicit field for data, it comes after bitmap (see next)\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleHeaderData // simplified {     HeapTupleFields t_heap;     ItemPointerData t_ctid;      // TID of this tuple or newer version     uint16          natts;       // number of attributes     uint16          t_infomask;  // flags e.g. has_null, has_varwidth     uint8           t_hoff;      // sizeof header incl. bitmap+padding     // above is fixed size (23 bytes) for all heap tuples     bits8           t_bits[1];   // bitmap of NULLs, variable length     // actual data follows at end of struct } HeapTupleHeaderData;",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Tuple-related data types: (cont)\n typedef struct HeapTupleFields  // simplified {     TransactionId t_xmin;  // inserting xact ID     TransactionId t_xmax;  // deleting or locking xact ID     CommandId     t_cid;   // inserting/deleting command ID } HeapTupleFields; Note that not all system fields from stored tuple appear\n both xmin/xmax are stored, but only one of cmin/cmax\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to resolve postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to mitigate postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution for postgresql tuples",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Provide me some Solution for postgresql tuples",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "mitigation for postgresql tuples",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to stop postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to defend postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to get secured against postgresql tuples ?",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "Solution, postgresql tuples",
  "answer": "Operations on Tuples:\n  // create Tuple from values HeapTuple heap_form_tuple(TupleDesc tupDesc, Datum *values, bool *isnull)  // return Datum given Tuple, attr and descriptor //   sets isnull to true if value is NULL #define heap_getattr(tup, attnum, tupleDesc, isnull) ...  // returns true if attribute has no value bool heap_attisnull(HeapTuple tup, int attnum) ...  // produce a modified tuple from an existing one HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc,                   Datum *replValues, bool *replIsnull,                   bool *doReplace) Implementing Relational Operations\n",
  "intent": "solution",
  "key_words": [
   "postgresql",
   "tuples"
  ]
 },
 {
  "question": "How to solve dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "How to resolve dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "How to mitigate dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Solution for dbms architecture (revisited)",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Provide me some Solution for dbms architecture (revisited)",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "mitigation for dbms architecture (revisited)",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "How to stop dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "How to defend dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "How to get secured against dbms architecture (revisited) ?",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "Solution, dbms architecture (revisited)",
  "answer": "Implementation of relational operations in DBMS:\n",
  "intent": "solution",
  "key_words": [
   "dbms",
   "architecture",
   "(revisited)"
  ]
 },
 {
  "question": "How to solve relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to resolve relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to mitigate relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Solution for relational operation",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Provide me some Solution for relational operation",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "mitigation for relational operation",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to stop relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to defend relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to get secured against relational operation ?",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Solution, relational operation",
  "answer": "DBMS core = relational engine, with implementations of\n selection, \u00a0 projection, \u00a0 join, \u00a0 set operations\n scanning, \u00a0 sorting, \u00a0 grouping, \u00a0 aggregation, \u00a0 ...\n In this part of the course:\n examine methods for implementing each operation\n develop cost models for each implementation\n characterise when each method is most effective\n Terminology reminder:\n tuple = record = collection of data values under some schema\n page = block = collection of tuples + management data = i/o unit\n relation = table \u2245 file = collection of tuples\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to solve relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to resolve relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to mitigate relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Solution for relational operation",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Provide me some Solution for relational operation",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "mitigation for relational operation",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to stop relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to defend relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to get secured against relational operation ?",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Solution, relational operation",
  "answer": "Two \"dimensions of variation\":\n which relational operation \u00a0 (e.g. Sel, Proj, Join, Sort, ...)\n which access-method \u00a0 (e.g. file struct: heap, indexed, hashed, ...)\n Each query method involves an operator and a file structure:\n e.g. primary-key selection on hashed file\n e.g. primary-key selection on indexed file\n e.g. join on ordered heap files (sort-merge join)\n e.g. join on hashed files (hash join)\n e.g. two-dimensional range query on R-tree indexed file\n As well as query costs, consider update costs (insert/delete).\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to solve relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to resolve relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to mitigate relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Solution for relational operation",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Provide me some Solution for relational operation",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "mitigation for relational operation",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to stop relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to defend relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to get secured against relational operation ?",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "Solution, relational operation",
  "answer": "SQL vs DBMS engine\n select ... from R where C\n find relevant tuples (satisfying C) in file(s) of R\n insert into R values(...)\n place new tuple in some page of a file of R\n delete from R where C\n find relevant tuples and \"remove\" from file(s) of R\n update R set ... where C\n find relevant tuples in file(s) of R and \"change\" them\n Cost Models\n",
  "intent": "solution",
  "key_words": [
   "relational",
   "operation"
  ]
 },
 {
  "question": "How to solve cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to resolve cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to mitigate cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution for cost model",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Provide me some Solution for cost model",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "mitigation for cost model",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to stop cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to defend cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to get secured against cost model ?",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution, cost model",
  "answer": "An important aspect of this course is\n analysis of cost of various query methods\n Cost can be measured in terms of\n Time Cost: total time taken to execute method, or\n Page Cost: number of pages read and/or written\n Primary assumptions in our cost models:\n memory (RAM) is \"small\", fast, byte-at-a-time\n disk storage is very large, slow, page-at-a-time\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to solve cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to resolve cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to mitigate cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution for cost model",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Provide me some Solution for cost model",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "mitigation for cost model",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to stop cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to defend cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to get secured against cost model ?",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution, cost model",
  "answer": "Since time cost is affected by many factors\n speed of i/o devices (fast/slow disk, SSD)\n load on machine\n we do not consider time cost in our analyses.\n For comparing methods, page cost is better\n identifies workload imposed by method\n BUT is clearly affected by buffering\n Trying to estimate costs with multiple concurrent ops and buffering is difficult!\n Addtional assumption: every page request leads to some i/o\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to solve cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to resolve cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to mitigate cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution for cost model",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Provide me some Solution for cost model",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "mitigation for cost model",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to stop cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to defend cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to get secured against cost model ?",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution, cost model",
  "answer": "In developing cost models, we also assume:\n a relation is a set of r tuples, with average size R bytes\n the tuples are stored in b data pages on disk\n each page has size B bytes and contains up to c tuples\n the tuples which answer query q are contained in bq pages\n data is transferred disk\u2194memory in whole pages\n cost of disk\u2194memory transfer Tr/w is very high\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to solve cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to resolve cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to mitigate cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution for cost model",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Provide me some Solution for cost model",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "mitigation for cost model",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to stop cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to defend cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to get secured against cost model ?",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "Solution, cost model",
  "answer": "Our cost models are \"rough\" (based on assumptions)\n But do give an O(x) feel for how expensive operations are.\n Example \"rough\" estimation: how many piano tuners in Sydney?\n Sydney has \u2245 4 000 000 people\n Average household size \u2245 3 \u2234 1 300 000 households\n Let's say that 1 in 10 households owns a piano\n Therefore there are \u2245 130 000 pianos\n Say people get their piano tuned every 2 years (on average)\n Say a tuner can do 2/day, 250 working-days/year\n Therefore 1 tuner can do 500 pianos per year\n Therefore Sydney would need \u2245 130000/2/500 = 130 tuners\n Actual number of tuners in Yellow Pages = 120\n Example borrowed from Alan Fekete at Sydney University.\n",
  "intent": "solution",
  "key_words": [
   "cost",
   "model"
  ]
 },
 {
  "question": "How to solve query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "How to resolve query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "How to mitigate query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Solution for query type",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Provide me some Solution for query type",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "mitigation for query type",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "How to stop query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "How to defend query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "How to get secured against query type ?",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "Solution, query type",
  "answer": "Type SQL RelAlg a.k.a.\n Scan select * from R R -\n Proj select x,y from R Proj[x,y]R -\n Sort select * from R  order by x\n Sort[x]R ord\n Sel1 select * from R  where id = k\n Sel[id=k]R one\n Seln select * from R  where a = k\n Sel[a=k]R -\n Join1 select * from R,S  where R.id = S.r\n R Join[id=r] S -\n Different query classes exhibit different query processing behaviours.\n",
  "intent": "solution",
  "key_words": [
   "query",
   "type"
  ]
 },
 {
  "question": "How to solve example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to resolve example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to mitigate example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Solution for example file structure",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Provide me some Solution for example file structure",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "mitigation for example file structure",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to stop example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to defend example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to get secured against example file structure ?",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Solution, example file structure",
  "answer": "When describing file structures\n use a large box to represent a page\n use either a small box or tupi (or reci) to represent a tuple\n sometimes refer to tuples via their key\n mostly, key corresponds to the notion of \"primary key\"\n sometimes, key means \"search key\" in selection condition\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to solve example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to resolve example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to mitigate example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Solution for example file structure",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Provide me some Solution for example file structure",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "mitigation for example file structure",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to stop example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to defend example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to get secured against example file structure ?",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "Solution, example file structure",
  "answer": "Consider three simple file structures:\n heap file ... tuples added to any page which has space\n sorted file ... tuples arranged in file in key order\n hash file ... tuples placed in pages using hash function\n All files are composed of b primary blocks/pages\n Some records in each page may be marked as \"deleted\".\n",
  "intent": "solution",
  "key_words": [
   "example",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to solve exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "How to resolve exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "How to mitigate exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Solution for exercise 7 operation cost",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 7 operation cost",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "mitigation for exercise 7 operation cost",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "How to stop exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "How to defend exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "How to get secured against exercise 7 operation cost ?",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "Solution, exercise 7 operation cost",
  "answer": "For each of the following file structures\n determine #page-reads + #page-writes for each operation\n You can assume the existence of a file header containing\n values for r, R, b, B, c\n index of first page with free space (and a free list)\n Assume also\n each page contains a header and directory as well as tuples\n no buffering \u00a0 (worst case scenario)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "7",
   "operation",
   "cost"
  ]
 },
 {
  "question": "How to solve operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to resolve operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to mitigate operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Solution for operation cost example",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Provide me some Solution for operation cost example",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "mitigation for operation cost example",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to stop operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to defend operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to get secured against operation cost example ?",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Solution, operation cost example",
  "answer": "Heap file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to solve operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to resolve operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to mitigate operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Solution for operation cost example",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Provide me some Solution for operation cost example",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "mitigation for operation cost example",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to stop operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to defend operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to get secured against operation cost example ?",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Solution, operation cost example",
  "answer": "Sorted file with b = 4, c = 4:\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to solve operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to resolve operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to mitigate operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Solution for operation cost example",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Provide me some Solution for operation cost example",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "mitigation for operation cost example",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to stop operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to defend operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to get secured against operation cost example ?",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "Solution, operation cost example",
  "answer": "Hashed file with b = 3, c = 4, h(k) = k%3\n Scanning\n",
  "intent": "solution",
  "key_words": [
   "operation",
   "cost",
   "example"
  ]
 },
 {
  "question": "How to solve scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to resolve scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to mitigate scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Solution for scanning",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Provide me some Solution for scanning",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "mitigation for scanning",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to stop scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to defend scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to get secured against scanning ?",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Solution, scanning",
  "answer": "Consider the query:\n select * from Rel; Operational view:\n for each page P in file of relation Rel {    for each tuple t in page P {       add tuple t to result set    } } Cost: read every data page once\n Time Cost = b.Tr, \u00a0\u00a0\u00a0 Page Cost = b\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to solve scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to resolve scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to mitigate scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Solution for scanning",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Provide me some Solution for scanning",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "mitigation for scanning",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to stop scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to defend scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to get secured against scanning ?",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Solution, scanning",
  "answer": "Scan implementation when file has overflow pages, e.g.\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to solve scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to resolve scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to mitigate scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Solution for scanning",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Provide me some Solution for scanning",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "mitigation for scanning",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to stop scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to defend scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to get secured against scanning ?",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "Solution, scanning",
  "answer": "In this case, the implementation changes to:\n for each page P in file of relation T {     for each tuple t in page P {         add tuple t to result set     }     for each overflow page V of page P {         for each tuple t in page V {             add tuple t to result set }   }   } Cost: read each data and overflow page once\n Cost = b + bOv\n where bOv = total number of overflow pages\n",
  "intent": "solution",
  "key_words": [
   "scanning"
  ]
 },
 {
  "question": "How to solve selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to resolve selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to mitigate selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Solution for selection via scanning",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Provide me some Solution for selection via scanning",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "mitigation for selection via scanning",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to stop selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to defend selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to get secured against selection via scanning ?",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Solution, selection via scanning",
  "answer": "Consider a one query like:\n select * from Employee where id = 762288; In an unordered file, search for matching tuple requires:\n   Guaranteed at most one answer; but could be in any page.\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to solve selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to resolve selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to mitigate selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Solution for selection via scanning",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Provide me some Solution for selection via scanning",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "mitigation for selection via scanning",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to stop selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to defend selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to get secured against selection via scanning ?",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "Solution, selection via scanning",
  "answer": "Overview of scan process:\n for each page P in relation Employee {     for each tuple t in page P {         if (t.id == 762288) return t }   } Cost analysis for one searching in unordered file\n best case: read one page, find tuple\n worst case: read all b pages, find in last (or don't find)\n average case: read half of the pages (b/2)\n Page Costs: \u00a0 Costavg = b/2 \u00a0\u00a0 Costmin = 1 \u00a0\u00a0 Costmax = b\n",
  "intent": "solution",
  "key_words": [
   "selection",
   "via",
   "scanning"
  ]
 },
 {
  "question": "How to solve exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "How to resolve exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "How to mitigate exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Solution for exercise 8 cost of search in hashed file",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 8 cost of search in hashed file",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "mitigation for exercise 8 cost of search in hashed file",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "How to stop exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "How to defend exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "How to get secured against exercise 8 cost of search in hashed file ?",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "Solution, exercise 8 cost of search in hashed file",
  "answer": "Consider the hashed file structure b = 10, c = 4, h(k) = k%10\n Describe how the following queries\n select * from R where k = 51; select * from R where k > 50; might be solved in a file structure like the above (h(k) = k%b).\n Estimate the minimum and maximum cost (as #pages read)\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "8",
   "cost",
   "of",
   "search",
   "in",
   "hashed",
   "file"
  ]
 },
 {
  "question": "How to solve relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to resolve relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to mitigate relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Solution for relation copying",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Provide me some Solution for relation copying",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "mitigation for relation copying",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to stop relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to defend relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to get secured against relation copying ?",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Solution, relation copying",
  "answer": "Consider an SQL statement like:\n create table T as (select * from S); Effectively, copies data from one file to another.\n Conceptually:\n make empty relation T for each tuple t in relation S {     append tuple t to relation T }",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to solve relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to resolve relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to mitigate relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Solution for relation copying",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Provide me some Solution for relation copying",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "mitigation for relation copying",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to stop relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to defend relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to get secured against relation copying ?",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "Solution, relation copying",
  "answer": "In terms of file operations:\n File inf,outf;    // input/output file handles int ip,op;        // input/output page numbers int i;            // tuple number in input buf Tuple t;          // current tuple Buffer ibuf,obuf; // input/output file buffers  inf = openFile(relFileName(\"S\"), READ); outf = openFile(relFileName(\"T\"), CREATE); clear(obuf); for (ip = op = 0; ip < nPages(inf); ip++) {     ibuf = readPage(inf, ip);     for (i = 0; i < nTuples(buf); i++) {         t = getTuple(ibuf, i);         addTuple(t, obuf);         if (isFull(obuf)) {             writePage(outf, op++, obuf);             clear(obuf); }   }   } if (nTuples(obuf) > 0) writePage(outf, op, obuf);",
  "intent": "solution",
  "key_words": [
   "relation",
   "copying"
  ]
 },
 {
  "question": "How to solve exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "How to resolve exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "How to mitigate exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Solution for exercise 9 cost of relation copy",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 9 cost of relation copy",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "mitigation for exercise 9 cost of relation copy",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "How to stop exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "How to defend exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "How to get secured against exercise 9 cost of relation copy ?",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "Solution, exercise 9 cost of relation copy",
  "answer": "Analyse cost for relation copying:\n 1. if both input and output are heap files\n 2. if input is sorted and output is heap file\n 3. if input is heap file and output is sorted\n Assume bin = number of pages in input file\n Give cost in terms of #pages read + #pages written\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "9",
   "cost",
   "of",
   "relation",
   "copy"
  ]
 },
 {
  "question": "How to solve exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "How to resolve exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "How to mitigate exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Solution for exercise 10 postgresql tuple visibility",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Provide me some Solution for exercise 10 postgresql tuple visibility",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "mitigation for exercise 10 postgresql tuple visibility",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "How to stop exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "How to defend exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "How to get secured against exercise 10 postgresql tuple visibility ?",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "Solution, exercise 10 postgresql tuple visibility",
  "answer": "Due to MVCC, PostgreSQL's getTuple(b,i) is not so simple\n ith tuple in buffer b may be \"live\" or \"dead\" or ... ?\n How does PostgreSQL recognise \"dead\" tuples?\n What possible states might tuples have?\n Assume: multiple concurrent transactions on tables.\n Hint: tuple = (oid,xmin,xmax,...rest of data...)\n Hint: include/access/htup.h\n Hint: backend/utils/time/tqual.c\n",
  "intent": "solution",
  "key_words": [
   "exercise",
   "10",
   "postgresql",
   "tuple",
   "visibility"
  ]
 },
 {
  "question": "How to solve scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to resolve scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to mitigate scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution for scanning in postgresql",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Provide me some Solution for scanning in postgresql",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "mitigation for scanning in postgresql",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to stop scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to defend scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to get secured against scanning in postgresql ?",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution, scanning in postgresql",
  "answer": "Scanning defined in: backend/access/heap/heapam.c\n Implements iterator data/operations:\n HeapScanDesc ... struct containing iteration state\n scan = heap_beginscan(rel,...,nkeys,keys)  (uses initscan() to do half the work (shared with rescan))\n tup = heap_getnext(scan, direction)  (uses heapgettup() to do most of the work)\n heap_endscan(scan) ... frees up scan struct\n HeapKeyTest() ... implements key match test\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to solve scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to resolve scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to mitigate scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution for scanning in postgresql",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Provide me some Solution for scanning in postgresql",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "mitigation for scanning in postgresql",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to stop scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to defend scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to get secured against scanning in postgresql ?",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "Solution, scanning in postgresql",
  "answer": "typedef struct HeapScanDescData {   // scan parameters    Relation      rs_rd;        // heap relation descriptor    Snapshot      rs_snapshot;  // snapshot ... tuple visibility    int           rs_nkeys;     // number of scan keys    ScanKey       rs_key;       // array of scan key descriptors    ...   // state set up at initscan time    PageNumber    rs_npages;    // number of pages to scan    PageNumber    rs_startpage; // page # to start at    ...   // scan current state, initally set to invalid    HeapTupleData rs_ctup;      // current tuple in scan   PageNumber    rs_cpage;     // current page # in scan   Buffer        rs_cbuf;      // current buffer in scan    ... } HeapScanDescData;",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "postgresql"
  ]
 },
 {
  "question": "How to solve scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to resolve scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to mitigate scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Solution for scanning in other file structure",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Provide me some Solution for scanning in other file structure",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "mitigation for scanning in other file structure",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to stop scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to defend scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "How to get secured against scanning in other file structure ?",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 },
 {
  "question": "Solution, scanning in other file structure",
  "answer": "Above examples are for heap files\n simple, unordered, maybe indexed, no hashing\n Other access file structures in PostgreSQL:\n btree, hash, gist, gin\n each implements:\n startscan, getnext, endscan\n insert, delete\n other file-specific operators\n Produced: 10 Aug 2018\n",
  "intent": "solution",
  "key_words": [
   "scanning",
   "in",
   "other",
   "file",
   "structure"
  ]
 }
]